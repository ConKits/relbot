<?xml version="1.0" encoding="UTF-8"?>
<testsuite
  name="relbot_simulator.uncrustify"
  tests="18"
  failures="17"
  errors="0"
  time="0.490"
>
  <testcase
    name="common/EulerAngles.cpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 4 lines"><![CDATA[--- common/EulerAngles.cpp
+++ common/EulerAngles.cpp.uncrustify
@@ -31 +30,0 @@
-
]]></failure>
  </testcase>
  <testcase
    name="common/EulerAngles.h"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 4 lines"><![CDATA[--- common/EulerAngles.h
+++ common/EulerAngles.h.uncrustify
@@ -31 +30,0 @@
-
]]></failure>
  </testcase>
  <testcase
    name="common/MotionProfiles.cpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 5 lines"><![CDATA[--- common/MotionProfiles.cpp
+++ common/MotionProfiles.cpp.uncrustify
@@ -18,2 +17,0 @@
-
-
]]></failure>
  </testcase>
  <testcase
    name="common/MotionProfiles.h"
    classname="relbot_simulator.uncrustify"/>
  <testcase
    name="common/xxfuncs.cpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 549 lines"><![CDATA[--- common/xxfuncs.cpp
+++ common/xxfuncs.cpp.uncrustify
@@ -37 +37 @@
-static const XXDouble xx_logarithm_2 =  0.6931471805599453;
+static const XXDouble xx_logarithm_2 = 0.6931471805599453;
@@ -44,19 +44,18 @@
-typedef union
-{
-	double m_double;
-	const char* m_char;
-}str2dbl;
-
-XXDouble XXString2Double(const char* argument)
-{
-	str2dbl myConversion;
-	myConversion.m_char = argument;
-	return myConversion.m_double;
-
-}
-
-const char* XXDouble2String(XXDouble argument)
-{
-	str2dbl myConversion;
-	myConversion.m_double = argument;
-	return myConversion.m_char;
+typedef union {
+  double m_double;
+  const char * m_char;
+} str2dbl;
+
+XXDouble XXString2Double(const char * argument)
+{
+  str2dbl myConversion;
+  myConversion.m_char = argument;
+  return myConversion.m_double;
+
+}
+
+const char * XXDouble2String(XXDouble argument)
+{
+  str2dbl myConversion;
+  myConversion.m_double = argument;
+  return myConversion.m_char;
@@ -66,52 +65,52 @@
-XXDouble XXAbsolute (XXDouble argument)
-{
-	return (XXDouble) fabs (argument);
-}
-
-XXDouble XXArcCosineHyperbolic (XXDouble argument)
-{
-	return (XXDouble) log (argument + sqrt(argument * argument - 1.0));
-}
-
-XXDouble XXArcSineHyperbolic (XXDouble argument)
-{
-	return (XXDouble) log (argument + sqrt(argument * argument + 1.0));
-}
-
-XXDouble XXArcTangentHyperbolic (XXDouble argument)
-{
-	return (XXDouble) 0.5 * log ((1.0 + argument) / (1.0 - argument));
-}
-
-XXDouble XXExponent2 (XXDouble argument)
-{
-	return (XXDouble) exp (argument * xx_logarithm_2);
-}
-
-XXDouble XXExponent10 (XXDouble argument)
-{
-	return (XXDouble) exp (argument * xx_logarithm_10);
-}
-
-XXDouble XXIntegerDivide (XXDouble argument1, XXDouble argument2)
-{
-	XXInteger value;
-
-	value = (XXInteger) (argument1 / argument2);
-	return (XXDouble) value;
-}
-
-XXDouble XXIntegerModulo (XXDouble argument1, XXDouble argument2)
-{
-	XXInteger value;
-
-	value = (XXInteger) (argument1 / argument2);
-	return (XXDouble) argument1 - (value * argument2);
-}
-
-XXDouble XXLogarithm2 (XXDouble argument)
-{
-	return (XXDouble) (log (argument) * xx_invLog2);
-}
-
-XXDouble XXLogarithm10 (XXDouble argument)
+XXDouble XXAbsolute(XXDouble argument)
+{
+  return (XXDouble) fabs (argument);
+}
+
+XXDouble XXArcCosineHyperbolic(XXDouble argument)
+{
+  return (XXDouble) log (argument + sqrt(argument * argument - 1.0));
+}
+
+XXDouble XXArcSineHyperbolic(XXDouble argument)
+{
+  return (XXDouble) log (argument + sqrt(argument * argument + 1.0));
+}
+
+XXDouble XXArcTangentHyperbolic(XXDouble argument)
+{
+  return (XXDouble) 0.5 * log ((1.0 + argument) / (1.0 - argument));
+}
+
+XXDouble XXExponent2(XXDouble argument)
+{
+  return (XXDouble) exp (argument * xx_logarithm_2);
+}
+
+XXDouble XXExponent10(XXDouble argument)
+{
+  return (XXDouble) exp (argument * xx_logarithm_10);
+}
+
+XXDouble XXIntegerDivide(XXDouble argument1, XXDouble argument2)
+{
+  XXInteger value;
+
+  value = (XXInteger) (argument1 / argument2);
+  return (XXDouble) value;
+}
+
+XXDouble XXIntegerModulo(XXDouble argument1, XXDouble argument2)
+{
+  XXInteger value;
+
+  value = (XXInteger) (argument1 / argument2);
+  return (XXDouble) argument1 - (value * argument2);
+}
+
+XXDouble XXLogarithm2(XXDouble argument)
+{
+  return (XXDouble) (log (argument) * xx_invLog2);
+}
+
+XXDouble XXLogarithm10(XXDouble argument)
@@ -120,2 +119,2 @@
-	/* C99 / C++ */
-	return (XXDouble) log10 (argument);
+        /* C99 / C++ */
+  return (XXDouble) log10 (argument);
@@ -123,2 +122,2 @@
-	/* Not C99 */
-	return (XXDouble) (log (argument) * xx_invLog10);
+        /* Not C99 */
+  return (XXDouble) (log (argument) * xx_invLog10);
@@ -128,72 +127,75 @@
-XXDouble XXPow2 (XXDouble argument)
-{
-	return argument * argument;
-}
-
-XXDouble XXPower (XXDouble argument1, XXDouble argument2)
-{
-	return (XXDouble) pow (argument1, argument2);
-}
-
-XXDouble XXRandom (XXDouble argument)
-{
-	XXDouble value;
-
-	value = (XXDouble) rand() / (XXDouble) RAND_MAX - 0.5;
-	return argument * 2.0 * value;
-}
-
-XXDouble XXRamp (XXDouble argument, XXDouble time)
-{
-	XXDouble value;
-
-	if (time < argument)
-		value = 0.0;
-	else
-		value = time - argument;
-	return value;
-}
-
-XXDouble XXSign (XXDouble argument)
-{
-	XXDouble value;
-	if (argument < 0.0)
-		value = -1.0;
-	else
-		if (argument == 0.0)
-			value = 0.0;
-		else
-			value = 1.0;
-	return value;
-}
-
-XXDouble XXStep (XXDouble steptime, XXDouble time)
-{
-	XXDouble value;
-
-	if (time < steptime)
-		value = 0.0;
-	else
-		value = 1.0;
-	return value;
-}
-
-XXDouble XXImpulse (XXDouble impulsestarttime, XXDouble impulseduration, XXDouble currenttime, XXDouble stepsize)
-{
-	XXDouble value;
-
-	if (stepsize <= 0.0 || impulseduration <= 0.0)
-		value = 0.0;
-	else
-	{
-		if ((currenttime < impulsestarttime) || (currenttime > (impulsestarttime + impulseduration)))
-			value = 0.0;
-		else
-		{
-			if (stepsize < impulseduration)
-				value = (1.0 / impulseduration);
-			else
-				value = (1.0 / stepsize);
-		}
-	}
-	return value;
+XXDouble XXPow2(XXDouble argument)
+{
+  return argument * argument;
+}
+
+XXDouble XXPower(XXDouble argument1, XXDouble argument2)
+{
+  return (XXDouble) pow (argument1, argument2);
+}
+
+XXDouble XXRandom(XXDouble argument)
+{
+  XXDouble value;
+
+  value = (XXDouble) rand() / (XXDouble) RAND_MAX - 0.5;
+  return argument * 2.0 * value;
+}
+
+XXDouble XXRamp(XXDouble argument, XXDouble time)
+{
+  XXDouble value;
+
+  if (time < argument) {
+    value = 0.0;
+  } else {
+    value = time - argument;
+  }
+  return value;
+}
+
+XXDouble XXSign(XXDouble argument)
+{
+  XXDouble value;
+  if (argument < 0.0) {
+    value = -1.0;
+  } else if (argument == 0.0) {
+    value = 0.0;
+  } else {
+    value = 1.0;
+  }
+  return value;
+}
+
+XXDouble XXStep(XXDouble steptime, XXDouble time)
+{
+  XXDouble value;
+
+  if (time < steptime) {
+    value = 0.0;
+  } else {
+    value = 1.0;
+  }
+  return value;
+}
+
+XXDouble XXImpulse(
+  XXDouble impulsestarttime, XXDouble impulseduration, XXDouble currenttime,
+  XXDouble stepsize)
+{
+  XXDouble value;
+
+  if (stepsize <= 0.0 || impulseduration <= 0.0) {
+    value = 0.0;
+  } else {
+    if ((currenttime < impulsestarttime) || (currenttime > (impulsestarttime + impulseduration))) {
+      value = 0.0;
+    } else {
+      if (stepsize < impulseduration) {
+        value = (1.0 / impulseduration);
+      } else {
+        value = (1.0 / stepsize);
+      }
+    }
+  }
+  return value;
@@ -204,22 +206,18 @@
-	return (argument1 || argument2) && !(argument1 && argument2);
-}
-
-XXDouble XXRound (XXDouble argument)
-{
-	XXDouble leftOver, result;
-
-	leftOver = argument - (XXInteger) argument;
-	if (fabs (leftOver) < 0.5)
-	{
-		result = (XXDouble) ((XXInteger) argument);
-	}
-	else
-	{
-		if (argument >= 0)
-			result = (XXDouble) ceil (argument);
-		else
-		{
-			result = (XXDouble) floor (argument);
-		}
-	}
-	return result;
+  return (argument1 || argument2) && !(argument1 && argument2);
+}
+
+XXDouble XXRound(XXDouble argument)
+{
+  XXDouble leftOver, result;
+
+  leftOver = argument - (XXInteger) argument;
+  if (fabs (leftOver) < 0.5) {
+    result = (XXDouble) ((XXInteger) argument);
+  } else {
+    if (argument >= 0) {
+      result = (XXDouble) ceil (argument);
+    } else {
+      result = (XXDouble) floor (argument);
+    }
+  }
+  return result;
@@ -230,2 +228,2 @@
-	/* bitwise and */
-	return (argument1 & argument2);
+        /* bitwise and */
+  return  argument1 & argument2;
@@ -236,2 +234,2 @@
-	/* bitwise or */
-	return  (argument1 | argument2);
+        /* bitwise or */
+  return   argument1 | argument2;
@@ -242,2 +240,2 @@
-	/* bitwise xor */
-	return (argument1 ^ argument2);
+        /* bitwise xor */
+  return  argument1 ^ argument2;
@@ -248,11 +246,10 @@
-	XXInteger maxBits = (XXInteger) sizeof(XXInteger) << 3;
-
-	/* calculate the maximum unsigned value for nrBits */
-	if (nrBits < maxBits)
-	{
-		XXInteger bits = (XXInteger) (1 << nrBits) - 1;
-		/* invert and only return the number of asked bits */
-		return (~argument & bits);
-	}
-
-	return(~argument);
+  XXInteger maxBits = (XXInteger) sizeof(XXInteger) << 3;
+
+        /* calculate the maximum unsigned value for nrBits */
+  if (nrBits < maxBits) {
+    XXInteger bits = (XXInteger) (1 << nrBits) - 1;
+                /* invert and only return the number of asked bits */
+    return  ~argument & bits;
+  }
+
+  return ~argument;
@@ -263,2 +260,2 @@
-	/* get the bit itself (prevent double shifting) */
-	return ((argument >> (bitPos - 1)) & 1);
+        /* get the bit itself (prevent double shifting) */
+  return  (argument >> (bitPos - 1)) & 1;
@@ -269 +266 @@
-	return ~argument;
+  return ~argument;
@@ -274,2 +271,2 @@
-	/* set the bit to 1 */
-	return (argument | (1 << (bitPos - 1)));
+        /* set the bit to 1 */
+  return  argument | (1 << (bitPos - 1));
@@ -280,2 +277,2 @@
-	/* reset the bit to 0 */
-	return (argument & ~(1 << (bitPos - 1)));
+        /* reset the bit to 0 */
+  return  argument & ~(1 << (bitPos - 1));
@@ -286,8 +283,5 @@
-	if ( bitsToShift > 0 )
-	{
-		return (argument << bitsToShift);
-	}
-	else
-	{
-		return (argument >> (-bitsToShift));
-	}
+  if (bitsToShift > 0) {
+    return  argument << bitsToShift;
+  } else {
+    return  argument >> (-bitsToShift);
+  }
@@ -298,8 +292,5 @@
-	if ( bitsToShift > 0 )
-	{
-		return (argument >> bitsToShift);
-	}
-	else
-	{
-		return (argument << (-bitsToShift));
-	}
+  if (bitsToShift > 0) {
+    return  argument >> bitsToShift;
+  } else {
+    return  argument << (-bitsToShift);
+  }
@@ -310,18 +301,18 @@
-	/* this function swaps the 4 bytes of a 32-bit integer (little-big endian) */
-	XXCharacter byte1;
-	XXCharacter byte2;
-	XXCharacter byte3;
-	XXCharacter byte4;
-	int result;
-	int arg1 = (int) argument;
-
-	/* get the separate bytes */
-	byte1 = (XXCharacter)(arg1 & 0xFF);
-	byte2 = (XXCharacter)((arg1 >> 8) & 0xFF);
-	byte3 = (XXCharacter)((arg1 >> 16) & 0xFF);
-	byte4 = (XXCharacter)((arg1 >> 24) & 0xFF);
-
-	/* do the explicit 32-bit swap */
-	result = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;
-
-	return (XXInteger) result;
+        /* this function swaps the 4 bytes of a 32-bit integer (little-big endian) */
+  XXCharacter byte1;
+  XXCharacter byte2;
+  XXCharacter byte3;
+  XXCharacter byte4;
+  int result;
+  int arg1 = (int) argument;
+
+        /* get the separate bytes */
+  byte1 = (XXCharacter)(arg1 & 0xFF);
+  byte2 = (XXCharacter)((arg1 >> 8) & 0xFF);
+  byte3 = (XXCharacter)((arg1 >> 16) & 0xFF);
+  byte4 = (XXCharacter)((arg1 >> 24) & 0xFF);
+
+        /* do the explicit 32-bit swap */
+  result = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;
+
+  return (XXInteger) result;
@@ -331,28 +322,28 @@
-XXDouble XXData (XXString name, XXInteger column, XXInteger id)
-{
-	return 0;
-}
-
-XXDouble XXTable (XXString name, XXDouble argument, XXInteger id)
-{
-	return 0;
-}
-
-XXBoolean XXFrequencyEvent (XXDouble argument, XXInteger id)
-{
-	return 0;
-}
-
-XXBoolean XXFrequencyEvent1 (XXDouble argument1, XXDouble argument2, XXInteger id)
-{
-	return 0;
-}
-
-XXDouble XXTimeDelay (XXDouble argument, XXDouble time, XXInteger id)
-{
-	return 0;
-}
-
-XXBoolean XXWarning (XXString message, XXInteger id)
-{
-	return 0;
+XXDouble XXData(XXString name, XXInteger column, XXInteger id)
+{
+  return 0;
+}
+
+XXDouble XXTable(XXString name, XXDouble argument, XXInteger id)
+{
+  return 0;
+}
+
+XXBoolean XXFrequencyEvent(XXDouble argument, XXInteger id)
+{
+  return 0;
+}
+
+XXBoolean XXFrequencyEvent1(XXDouble argument1, XXDouble argument2, XXInteger id)
+{
+  return 0;
+}
+
+XXDouble XXTimeDelay(XXDouble argument, XXDouble time, XXInteger id)
+{
+  return 0;
+}
+
+XXBoolean XXWarning(XXString message, XXInteger id)
+{
+  return 0;
@@ -367,14 +358,10 @@
-	XXDouble seconds = 0.0;
-	
-	if (xx_start_run_time == 0)
-	{
-		time(&xx_start_run_time);
-	}
-	else
-	{
-		seconds = (XXDouble) difftime(time(NULL), xx_start_run_time);
-	}
-	
-	return seconds;
-}
-
+  XXDouble seconds = 0.0;
+
+  if (xx_start_run_time == 0) {
+    time(&xx_start_run_time);
+  } else {
+    seconds = (XXDouble) difftime(time(NULL), xx_start_run_time);
+  }
+
+  return seconds;
+}
]]></failure>
  </testcase>
  <testcase
    name="common/xxfuncs.h"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 63 lines"><![CDATA[--- common/xxfuncs.h
+++ common/xxfuncs.h.uncrustify
@@ -21,2 +21,2 @@
-XXDouble XXString2Double(const char* argument);
-const char* XXDouble2String(XXDouble argument);
+XXDouble XXString2Double(const char * argument);
+const char * XXDouble2String(XXDouble argument);
@@ -25,19 +25,21 @@
-XXDouble XXAbsolute (XXDouble argument);
-XXDouble XXArcCosineHyperbolic (XXDouble argument);
-XXDouble XXArcSineHyperbolic (XXDouble argument);
-XXDouble XXArcTangentHyperbolic (XXDouble argument);
-XXDouble XXExponent2 (XXDouble argument);
-XXDouble XXExponent10 (XXDouble argument);
-XXDouble XXIntegerDivide (XXDouble argument1, XXDouble argument2);
-XXDouble XXIntegerModulo (XXDouble argument1, XXDouble argument2);
-XXDouble XXLogarithm2 (XXDouble argument);
-XXDouble XXLogarithm10 (XXDouble argument);
-XXDouble XXPow2 (XXDouble argument);
-XXDouble XXPower (XXDouble argument1, XXDouble argument2);
-XXDouble XXRandom (XXDouble argument);
-XXDouble XXRamp (XXDouble argument, XXDouble time);
-XXDouble XXRound (XXDouble argument);
-XXDouble XXSign (XXDouble argument);
-XXDouble XXStep (XXDouble argument, XXDouble time);
-XXDouble XXImpulse (XXDouble impulsestarttime, XXDouble impulseduration, XXDouble currenttime, XXDouble stepsize);
-XXDouble XXXor (XXDouble argument1, XXDouble argument2);
+XXDouble XXAbsolute(XXDouble argument);
+XXDouble XXArcCosineHyperbolic(XXDouble argument);
+XXDouble XXArcSineHyperbolic(XXDouble argument);
+XXDouble XXArcTangentHyperbolic(XXDouble argument);
+XXDouble XXExponent2(XXDouble argument);
+XXDouble XXExponent10(XXDouble argument);
+XXDouble XXIntegerDivide(XXDouble argument1, XXDouble argument2);
+XXDouble XXIntegerModulo(XXDouble argument1, XXDouble argument2);
+XXDouble XXLogarithm2(XXDouble argument);
+XXDouble XXLogarithm10(XXDouble argument);
+XXDouble XXPow2(XXDouble argument);
+XXDouble XXPower(XXDouble argument1, XXDouble argument2);
+XXDouble XXRandom(XXDouble argument);
+XXDouble XXRamp(XXDouble argument, XXDouble time);
+XXDouble XXRound(XXDouble argument);
+XXDouble XXSign(XXDouble argument);
+XXDouble XXStep(XXDouble argument, XXDouble time);
+XXDouble XXImpulse(
+  XXDouble impulsestarttime, XXDouble impulseduration, XXDouble currenttime,
+  XXDouble stepsize);
+XXDouble XXXor(XXDouble argument1, XXDouble argument2);
@@ -60,6 +62,6 @@
-XXDouble XXData (XXString name, XXInteger column, XXInteger id);
-XXDouble XXTable (XXString name, XXDouble argument, XXInteger id);
-XXBoolean XXFrequencyEvent (XXDouble argument, XXInteger id);
-XXBoolean XXFrequencyEvent1 (XXDouble argument1, XXDouble argument2, XXInteger id);
-XXDouble XXTimeDelay (XXDouble argument, XXDouble time, XXInteger id);
-XXBoolean XXWarning (XXString message, XXInteger id);
+XXDouble XXData(XXString name, XXInteger column, XXInteger id);
+XXDouble XXTable(XXString name, XXDouble argument, XXInteger id);
+XXBoolean XXFrequencyEvent(XXDouble argument, XXInteger id);
+XXBoolean XXFrequencyEvent1(XXDouble argument1, XXDouble argument2, XXInteger id);
+XXDouble XXTimeDelay(XXDouble argument, XXDouble time, XXInteger id);
+XXBoolean XXWarning(XXString message, XXInteger id);
@@ -69 +70,0 @@
-
]]></failure>
  </testcase>
  <testcase
    name="common/xxinteg.cpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 510 lines"><![CDATA[--- common/xxinteg.cpp
+++ common/xxinteg.cpp.uncrustify
@@ -42 +42 @@
-	model = NULL;
+  model = NULL;
@@ -52,4 +52,4 @@
-void Discrete::Initialize (Submodel20sim* themodel)
-{
-	model = themodel;
-	model->m_major = true;
+void Discrete::Initialize(Submodel20sim * themodel)
+{
+  model = themodel;
+  model->m_major = true;
@@ -59,3 +59,3 @@
-void Discrete::Terminate ()
-{
-	/* nothing to be done */
+void Discrete::Terminate()
+{
+        /* nothing to be done */
@@ -65,17 +65,16 @@
-void Discrete::Step ()
-{
-	XXInteger index;
-
-	/* for each of the supplied states */
-	for (index = 0; index < model->m_number_states; index++)
-	{
-		/* just a move of the new state */
-		model->m_s [index] = model->m_R [index];
-	}
-
-	/* increment the simulation time */
-	model->m_time += model->m_step_size;
-	model->m_major = true;
-
-	/* evaluate the dynamic part to calculate the new rates */
-	model->CalculateDynamic ();
+void Discrete::Step()
+{
+  XXInteger index;
+
+        /* for each of the supplied states */
+  for (index = 0; index < model->m_number_states; index++) {
+                /* just a move of the new state */
+    model->m_s[index] = model->m_R[index];
+  }
+
+        /* increment the simulation time */
+  model->m_time += model->m_step_size;
+  model->m_major = true;
+
+        /* evaluate the dynamic part to calculate the new rates */
+  model->CalculateDynamic ();
@@ -89 +88 @@
-	model = NULL;
+  model = NULL;
@@ -99,4 +98,4 @@
-void Euler::Initialize(Submodel20sim* themodel)
-{
-	model = themodel;
-	model->m_major = true;
+void Euler::Initialize(Submodel20sim * themodel)
+{
+  model = themodel;
+  model->m_major = true;
@@ -106,3 +105,3 @@
-void Euler::Terminate ()
-{
-	/* nothing to be done */
+void Euler::Terminate()
+{
+        /* nothing to be done */
@@ -112,17 +111,16 @@
-void Euler::Step ()
-{
-	XXInteger index;
-
-	/* for each of the supplied states */
-	for (index = 0; index < model->m_number_states; index++)
-	{
-		/* calculate the new state */
-		model->m_s [index] += model->m_R [index] * model->m_step_size;
-	}
-
-	/* increment the simulation time */
-	model->m_time += model->m_step_size;
-	model->m_major = true;
-
-	/* evaluate the dynamic part to calculate the new rates */
-	model->CalculateDynamic ();
+void Euler::Step()
+{
+  XXInteger index;
+
+        /* for each of the supplied states */
+  for (index = 0; index < model->m_number_states; index++) {
+                /* calculate the new state */
+    model->m_s[index] += model->m_R[index] * model->m_step_size;
+  }
+
+        /* increment the simulation time */
+  model->m_time += model->m_step_size;
+  model->m_major = true;
+
+        /* evaluate the dynamic part to calculate the new rates */
+  model->CalculateDynamic ();
@@ -135,4 +133,4 @@
-RungeKutta2::RungeKutta2(void):
-	q0(NULL)
-{
-	model = NULL;
+RungeKutta2::RungeKutta2(void)
+:q0(NULL)
+{
+  model = NULL;
@@ -143,2 +141,3 @@
-	if (q0)
-		delete[] q0;
+  if (q0) {
+    delete[] q0;
+  }
@@ -150,11 +149,10 @@
-void RungeKutta2::Initialize (Submodel20sim* themodel)
-{
-	model = themodel;
-	
-	/* allocate and empty the q0 array */
-	if (q0 == NULL)
-	{
-		q0 = new XXDouble [model->m_number_states + 1];
-	}
-
-	memset (q0, '\0', (model->m_number_states + 1) * sizeof (XXDouble));
+void RungeKutta2::Initialize(Submodel20sim * themodel)
+{
+  model = themodel;
+
+        /* allocate and empty the q0 array */
+  if (q0 == NULL) {
+    q0 = new XXDouble[model->m_number_states + 1];
+  }
+
+  memset (q0, '\0', (model->m_number_states + 1) * sizeof(XXDouble));
@@ -164 +162 @@
-void RungeKutta2::Terminate ()
+void RungeKutta2::Terminate()
@@ -169,53 +167,48 @@
-void RungeKutta2::Step ()
-{
-	XXInteger index;
-	XXDouble rktime;
-
-	/* check if we have states at all */
-	if (model->m_number_states > 0)
-	{
-		/*********************************************************************************/
-		/*         calculate intermediate result                                         */
-		/*********************************************************************************/
-
-		/* cache the simulation time */
-		rktime = model->m_time;
-
-		/* the q0 will hold the value of the last evaluation. This is used multiple times
-		   so remember the complete state array in this vector. */
-		memcpy (q0, model->m_s, model->m_number_states * sizeof (XXDouble));
-
-		/* calculate f (states, t) * 1/2 * dt  =  rates * 1/2 * dt  */
-		for (index = 0; index < model->m_number_states; index++)
-		{
-			/* set the new states to use */
-			model->m_s [index] = q0[index] + model->m_R[index] * 0.5 * model->m_step_size;
-		}
-
-		model->m_time = rktime + 0.5 * model->m_step_size;
-		model->m_major = false;
-		model->CalculateDynamic ();
-
-		/* for each state */
-		for (index = 0; index < model->m_number_states; index++)
-		{
-			/*********************************************************************************/
-			/*          calculate the next state from the intermediate results               */
-			/*********************************************************************************/
-
-			/* calculate the next state = classical Runge-Kutta integration step */
-			model->m_s [index] = q0 [index] + model->m_R [index] * model->m_step_size;
-		}
-		model->m_time = rktime + model->m_step_size;
-	}
-	else
-	{
-		/* no states in the model */
-		/* increment the simulation time */
-		model->m_time += model->m_step_size;
-	}
-
-	model->m_major = true;
-
-	/* evaluate the derivative model to calculate the new rates */
-	model->CalculateDynamic ();
+void RungeKutta2::Step()
+{
+  XXInteger index;
+  XXDouble rktime;
+
+        /* check if we have states at all */
+  if (model->m_number_states > 0) {
+                /*********************************************************************************/
+                /*         calculate intermediate result                                         */
+                /*********************************************************************************/
+
+                /* cache the simulation time */
+    rktime = model->m_time;
+
+                /* the q0 will hold the value of the last evaluation. This is used multiple times
+                   so remember the complete state array in this vector. */
+    memcpy (q0, model->m_s, model->m_number_states * sizeof(XXDouble));
+
+                /* calculate f (states, t) * 1/2 * dt  =  rates * 1/2 * dt  */
+    for (index = 0; index < model->m_number_states; index++) {
+                        /* set the new states to use */
+      model->m_s[index] = q0[index] + model->m_R[index] * 0.5 * model->m_step_size;
+    }
+
+    model->m_time = rktime + 0.5 * model->m_step_size;
+    model->m_major = false;
+    model->CalculateDynamic ();
+
+                /* for each state */
+    for (index = 0; index < model->m_number_states; index++) {
+                        /*********************************************************************************/
+                        /*          calculate the next state from the intermediate results               */
+                        /*********************************************************************************/
+
+                        /* calculate the next state = classical Runge-Kutta integration step */
+      model->m_s[index] = q0[index] + model->m_R[index] * model->m_step_size;
+    }
+    model->m_time = rktime + model->m_step_size;
+  } else {
+                /* no states in the model */
+                /* increment the simulation time */
+    model->m_time += model->m_step_size;
+  }
+
+  model->m_major = true;
+
+        /* evaluate the derivative model to calculate the new rates */
+  model->CalculateDynamic ();
@@ -228,8 +221,8 @@
-RungeKutta4::RungeKutta4(void):
-	q0(NULL),
-	q1(NULL),
-	q2(NULL),
-	q3(NULL),
-	q4(NULL)
-{
-	model = NULL;
+RungeKutta4::RungeKutta4(void)
+:q0(NULL),
+  q1(NULL),
+  q2(NULL),
+  q3(NULL),
+  q4(NULL)
+{
+  model = NULL;
@@ -240,8 +233,7 @@
-	if (q0)
-	{
-		delete[] q0;
-		delete[] q1;
-		delete[] q2;
-		delete[] q3;
-		delete[] q4;
-	}
+  if (q0) {
+    delete[] q0;
+    delete[] q1;
+    delete[] q2;
+    delete[] q3;
+    delete[] q4;
+  }
@@ -254,20 +246,19 @@
-void RungeKutta4::Initialize (Submodel20sim* themodel)
-{
-	model = themodel;
-	
-	/* allocate internal arrays */
-	if (q0 == NULL)
-	{
-		q0 = new XXDouble [model->m_number_states + 1];
-		q1 = new XXDouble [model->m_number_states + 1];
-		q2 = new XXDouble [model->m_number_states + 1];
-		q3 = new XXDouble [model->m_number_states + 1];
-		q4 = new XXDouble [model->m_number_states + 1];
-	}
-
-	/* empty our internal arrays */
-	memset (q0, '\0', (model->m_number_states + 1) * sizeof (XXDouble));
-	memset (q1, '\0', (model->m_number_states + 1) * sizeof (XXDouble));
-	memset (q2, '\0', (model->m_number_states + 1) * sizeof (XXDouble));
-	memset (q3, '\0', (model->m_number_states + 1) * sizeof (XXDouble));
-	memset (q4, '\0', (model->m_number_states + 1) * sizeof (XXDouble));
+void RungeKutta4::Initialize(Submodel20sim * themodel)
+{
+  model = themodel;
+
+        /* allocate internal arrays */
+  if (q0 == NULL) {
+    q0 = new XXDouble[model->m_number_states + 1];
+    q1 = new XXDouble[model->m_number_states + 1];
+    q2 = new XXDouble[model->m_number_states + 1];
+    q3 = new XXDouble[model->m_number_states + 1];
+    q4 = new XXDouble[model->m_number_states + 1];
+  }
+
+        /* empty our internal arrays */
+  memset (q0, '\0', (model->m_number_states + 1) * sizeof(XXDouble));
+  memset (q1, '\0', (model->m_number_states + 1) * sizeof(XXDouble));
+  memset (q2, '\0', (model->m_number_states + 1) * sizeof(XXDouble));
+  memset (q3, '\0', (model->m_number_states + 1) * sizeof(XXDouble));
+  memset (q4, '\0', (model->m_number_states + 1) * sizeof(XXDouble));
@@ -277,3 +268,3 @@
-void RungeKutta4::Terminate (void)
-{
-	/* nothing yet */
+void RungeKutta4::Terminate(void)
+{
+        /* nothing yet */
@@ -283,93 +274,86 @@
-void RungeKutta4::Step ()
-{
-	XXInteger index;
-	XXDouble rktime;
-
-	/* check if we have states at all */
-	if (model->m_number_states > 0)
-	{
-		/*********************************************************************************/
-		/*          calculate intermediate state results q1, q2, q3 and q4               */
-		/*********************************************************************************/
-
-		/* cache the simulation time */
-		rktime = model->m_time;
-
-		/* the q0 will hold the value of the last evaluation. This is used multiple times
-		   so remember the complete state array in this vector. */
-		memcpy (q0, model->m_s, model->m_number_states * sizeof (XXDouble));
-
-		/* calculate q1 = f (states, t) * dt  =  rates * dt  */
-		for (index = 0; index < model->m_number_states; index++)
-		{
-			/* set the intermediate q1 */
-			q1 [index] = model->m_R [index] * model->m_step_size;
-
-			/* set the new states to use  for q2 */
-			model->m_s [index] = q0 [index] + q1 [index] / 2;
-		}
-
-		/* calculate q2 = f (states + q1 / 2, t + dt / 2) * dt  */
-		model->m_time = rktime + model->m_step_size / 2;
-
-		model->m_major = false;
-
-		model->CalculateDynamic ();
-		memcpy (q2, model->m_R, model->m_number_states * sizeof (XXDouble));
-
-		/* for each state */
-		for (index = 0; index < model->m_number_states; index++)
-		{
-			/* set the ultimate q2 */
-			q2 [index] = q2 [index] * model->m_step_size;
-
-			/* set the new states to use */
-			model->m_s [index] = q0 [index] + q2 [index] / 2;
-		}
-
-		/* calculate q3 = f (states + q2 / 2, t + dt / 2) * dt  */
-		model->CalculateDynamic ();
-		memcpy (q3, model->m_R, model->m_number_states * sizeof (XXDouble));
-
-		/* for each state */
-		for (index = 0; index < model->m_number_states; index++)
-		{
-			/* set the ultimate q3 */
-			q3 [index] = q3 [index] * model->m_step_size;
-
-			/* set the new states */
-			model->m_s [index] = q0 [index] + q3 [index];
-		}
-
-		/* calculate q4 = f (states + q3, t + dt) * dt */
-		model->m_time = rktime + model->m_step_size;
-		model->CalculateDynamic ();
-		memcpy (q4, model->m_R, model->m_number_states * sizeof (XXDouble));
-
-		/* for each state */
-		for (index = 0; index < model->m_number_states; index++)
-		{
-			/* set the ultimate q4 */
-			q4 [index] = q4 [index] * model->m_step_size;
-
-			/*********************************************************************************/
-			/*          calculate the next state from the intermediate results               */
-			/*********************************************************************************/
-
-			/* calculate the next state = classical Runge-Kutta integration step */
-			model->m_s[index] = q0[index] + (q1[index] + q2[index] + q2[index] + q3[index] + q3[index] + q4[index]) * OneOverSix;
-		}
-	}
-	else
-	{
-		/* no states in the model */
-		/* increment the simulation time */
-		model->m_time += model->m_step_size;
-	}
-
-	model->m_major = true;
-
-	/* evaluate the derivative model to calculate the new rates */
-	model->CalculateDynamic ();
-}
-
+void RungeKutta4::Step()
+{
+  XXInteger index;
+  XXDouble rktime;
+
+        /* check if we have states at all */
+  if (model->m_number_states > 0) {
+                /*********************************************************************************/
+                /*          calculate intermediate state results q1, q2, q3 and q4               */
+                /*********************************************************************************/
+
+                /* cache the simulation time */
+    rktime = model->m_time;
+
+                /* the q0 will hold the value of the last evaluation. This is used multiple times
+                   so remember the complete state array in this vector. */
+    memcpy (q0, model->m_s, model->m_number_states * sizeof(XXDouble));
+
+                /* calculate q1 = f (states, t) * dt  =  rates * dt  */
+    for (index = 0; index < model->m_number_states; index++) {
+                        /* set the intermediate q1 */
+      q1[index] = model->m_R[index] * model->m_step_size;
+
+                        /* set the new states to use  for q2 */
+      model->m_s[index] = q0[index] + q1[index] / 2;
+    }
+
+                /* calculate q2 = f (states + q1 / 2, t + dt / 2) * dt  */
+    model->m_time = rktime + model->m_step_size / 2;
+
+    model->m_major = false;
+
+    model->CalculateDynamic ();
+    memcpy (q2, model->m_R, model->m_number_states * sizeof(XXDouble));
+
+                /* for each state */
+    for (index = 0; index < model->m_number_states; index++) {
+                        /* set the ultimate q2 */
+      q2[index] = q2[index] * model->m_step_size;
+
+                        /* set the new states to use */
+      model->m_s[index] = q0[index] + q2[index] / 2;
+    }
+
+                /* calculate q3 = f (states + q2 / 2, t + dt / 2) * dt  */
+    model->CalculateDynamic ();
+    memcpy (q3, model->m_R, model->m_number_states * sizeof(XXDouble));
+
+                /* for each state */
+    for (index = 0; index < model->m_number_states; index++) {
+                        /* set the ultimate q3 */
+      q3[index] = q3[index] * model->m_step_size;
+
+                        /* set the new states */
+      model->m_s[index] = q0[index] + q3[index];
+    }
+
+                /* calculate q4 = f (states + q3, t + dt) * dt */
+    model->m_time = rktime + model->m_step_size;
+    model->CalculateDynamic ();
+    memcpy (q4, model->m_R, model->m_number_states * sizeof(XXDouble));
+
+                /* for each state */
+    for (index = 0; index < model->m_number_states; index++) {
+                        /* set the ultimate q4 */
+      q4[index] = q4[index] * model->m_step_size;
+
+                        /*********************************************************************************/
+                        /*          calculate the next state from the intermediate results               */
+                        /*********************************************************************************/
+
+                        /* calculate the next state = classical Runge-Kutta integration step */
+      model->m_s[index] = q0[index] +
+        (q1[index] + q2[index] + q2[index] + q3[index] + q3[index] + q4[index]) * OneOverSix;
+    }
+  } else {
+                /* no states in the model */
+                /* increment the simulation time */
+    model->m_time += model->m_step_size;
+  }
+
+  model->m_major = true;
+
+        /* evaluate the derivative model to calculate the new rates */
+  model->CalculateDynamic ();
+}
]]></failure>
  </testcase>
  <testcase
    name="common/xxinteg.h"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 102 lines"><![CDATA[--- common/xxinteg.h
+++ common/xxinteg.h.uncrustify
@@ -20 +20 @@
-class Submodel20sim;	//Forward declaration
+class Submodel20sim;    //Forward declaration
@@ -24,9 +24,11 @@
-  public:
-	IntegrationMethod(void): model(NULL) {	};
-	virtual ~IntegrationMethod(void) {	};
-	virtual void Initialize(Submodel20sim* themodel) = 0;
-	virtual void Terminate() = 0;
-	virtual void Step() = 0;
-	
-  protected:
-	Submodel20sim* model;
+public:
+  IntegrationMethod(void) : model(NULL) {
+  };
+  virtual ~IntegrationMethod(void) {
+  };
+  virtual void Initialize(Submodel20sim * themodel) = 0;
+  virtual void Terminate() = 0;
+  virtual void Step() = 0;
+
+protected:
+  Submodel20sim * model;
@@ -37,6 +39,6 @@
-  public:
-	Euler(void);
-	~Euler(void);
-	void Initialize(Submodel20sim* themodel);
-	void Terminate();
-	void Step();
+public:
+  Euler(void);
+  ~Euler(void);
+  void Initialize(Submodel20sim * themodel);
+  void Terminate();
+  void Step();
@@ -47,6 +49,6 @@
-  public:
-	Discrete(void);
-	~Discrete(void);
-	void Initialize(Submodel20sim* themodel);
-	void Terminate();
-	void Step();
+public:
+  Discrete(void);
+  ~Discrete(void);
+  void Initialize(Submodel20sim * themodel);
+  void Terminate();
+  void Step();
@@ -57,14 +59,14 @@
-  public:
-	RungeKutta4(void);
-	~RungeKutta4(void);
-	void Initialize(Submodel20sim* themodel);
-	void Terminate();
-	void Step();
-	
-  private:
-	XXDouble* q0;
-	XXDouble* q1;
-	XXDouble* q2;
-	XXDouble* q3;
-	XXDouble* q4;
-	const XXDouble OneOverSix = 1.0 / 6.0;
+public:
+  RungeKutta4(void);
+  ~RungeKutta4(void);
+  void Initialize(Submodel20sim * themodel);
+  void Terminate();
+  void Step();
+
+private:
+  XXDouble * q0;
+  XXDouble * q1;
+  XXDouble * q2;
+  XXDouble * q3;
+  XXDouble * q4;
+  const XXDouble OneOverSix = 1.0 / 6.0;
@@ -75,9 +77,9 @@
-  public:
-	RungeKutta2(void);
-	~RungeKutta2(void);
-	void Initialize(Submodel20sim* themodel);
-	void Terminate();
-	void Step();
-	
-  private:
-	XXDouble* q0;
+public:
+  RungeKutta2(void);
+  ~RungeKutta2(void);
+  void Initialize(Submodel20sim * themodel);
+  void Terminate();
+  void Step();
+
+private:
+  XXDouble * q0;
@@ -87 +88,0 @@
-
]]></failure>
  </testcase>
  <testcase
    name="common/xxinverse.cpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 642 lines"><![CDATA[--- common/xxinverse.cpp
+++ common/xxinverse.cpp.uncrustify
@@ -32,12 +32,14 @@
-void XXIndex (XXMatrix *v)
-{
-	/* We dont know if it is horizontal or vertical */
-	XXInteger i, size;
-
-	if( v->rows > v->columns )
-		size = v->rows;
-	else
-		size = v->columns;
-
-	for(i = 0; i < size; i++)
-		v->mat[i] = (XXDouble) i;
+void XXIndex(XXMatrix *v)
+{
+        /* We dont know if it is horizontal or vertical */
+  XXInteger i, size;
+
+  if(v->rows > v->columns) {
+    size = v->rows;
+  } else {
+    size = v->columns;
+  }
+
+  for(i = 0; i < size; i++) {
+    v->mat[i] = (XXDouble) i;
+  }
@@ -50,15 +52,17 @@
-void XXPermute (XXMatrix *v, XXMatrix *p, XXDouble *workarray)
-{
-	/* we dont know if it is horizontal or vertical */
-	XXInteger i, size;
-
-	if( v->rows > v->columns )
-		size = v->rows;
-	else
-		size = v->columns;
-
-	for( i = 0; i < size; i++)
-		workarray[i] = v->mat[(XXInteger)p->mat[i]];
-
-	/* and copy the values back to the matrix v */
-	memcpy(v->mat, workarray, size * sizeof(XXDouble));
+void XXPermute(XXMatrix *v, XXMatrix *p, XXDouble *workarray)
+{
+        /* we dont know if it is horizontal or vertical */
+  XXInteger i, size;
+
+  if(v->rows > v->columns) {
+    size = v->rows;
+  } else {
+    size = v->columns;
+  }
+
+  for( i = 0; i < size; i++) {
+    workarray[i] = v->mat[(XXInteger)p->mat[i]];
+  }
+
+        /* and copy the values back to the matrix v */
+  memcpy(v->mat, workarray, size * sizeof(XXDouble));
@@ -71,33 +75,32 @@
-void XXSubstitute (XXMatrix *dest, XXMatrix *v)
-{
-	XXDouble t, diag;
-	XXInteger i, j, rows, columns;
-
-	rows = dest->rows;
-	columns = dest->columns;
-
-	/* forward substitution.*/
-	for( i = 0; i < rows; i++)
-	{
-		t = v->mat[i];
-		for( j = 0; j < i; j++ )
-			t -= dest->mat[i*columns+j] * v->mat[j];
-
-		diag = dest->mat[i*columns+i];
-		if( diag == 0.0 )
-		{
-			/* error */
-			return;
-		}
-		t /= diag;
-		v->mat[i] = t;
-	}
-
-	/* back substitution */
-	for( i = rows-1 ; i >= 0; i-- )
-	{
-		t = v->mat[i];
-		for( j = i+1 ; j < rows; j++)
-			t -= dest->mat[i*columns+j] * v->mat[j];
-		v->mat[i] = t;
-	}
+void XXSubstitute(XXMatrix *dest, XXMatrix *v)
+{
+  XXDouble t, diag;
+  XXInteger i, j, rows, columns;
+
+  rows = dest->rows;
+  columns = dest->columns;
+
+        /* forward substitution.*/
+  for( i = 0; i < rows; i++) {
+    t = v->mat[i];
+    for( j = 0; j < i; j++ ) {
+      t -= dest->mat[i * columns + j] * v->mat[j];
+    }
+
+    diag = dest->mat[i * columns + i];
+    if(diag == 0.0) {
+                        /* error */
+      return;
+    }
+    t /= diag;
+    v->mat[i] = t;
+  }
+
+        /* back substitution */
+  for( i = rows - 1 ; i >= 0; i-- ) {
+    t = v->mat[i];
+    for( j = i + 1 ; j < rows; j++) {
+      t -= dest->mat[i * columns + j] * v->mat[j];
+    }
+    v->mat[i] = t;
+  }
@@ -109,13 +112,12 @@
-void XXSwapRows (XXMatrix *dest, XXInteger row1, XXInteger row2)
-{
-	XXDouble temp;
-	XXInteger i, columns;
-
-	columns = dest->columns;
-
-	for( i = 0; i < columns; i++)
-	{
-		temp = dest->mat[row1 * columns + i];
-		dest->mat[row1 * columns + i] = dest->mat[row2 * columns + i];
-		dest->mat[row2 * columns + i] = temp;
-	}
+void XXSwapRows(XXMatrix *dest, XXInteger row1, XXInteger row2)
+{
+  XXDouble temp;
+  XXInteger i, columns;
+
+  columns = dest->columns;
+
+  for( i = 0; i < columns; i++) {
+    temp = dest->mat[row1 * columns + i];
+    dest->mat[row1 * columns + i] = dest->mat[row2 * columns + i];
+    dest->mat[row2 * columns + i] = temp;
+  }
@@ -130,29 +132,26 @@
-XXInteger XXPivot (XXMatrix *dest, XXMatrix *p, XXInteger i)
-{
-	XXInteger j, k, rows, columns, sgn;
-	XXDouble t, mki;
-
-	rows = dest->rows;
-	columns = dest->columns;
-
-	j = i;
-	sgn = 1;
-	t = 0;
-
-	for( k = i; k < rows; k++)
-	{
-		mki = (XXDouble) fabs(dest->mat[k*columns+i]);
-		if( mki > t )
-		{
-			t = mki;
-			j = k;
-		}
-	}
-
-	if( j > i )
-	{
-		XXSwapRows(dest, i, j); /* swap matrix rows   */
-		XXSwapRows(p, i, j);    /* swap indices       */
-		sgn = -sgn;             /* change sign of det */
-	}
-	return sgn;
+XXInteger XXPivot(XXMatrix *dest, XXMatrix *p, XXInteger i)
+{
+  XXInteger j, k, rows, columns, sgn;
+  XXDouble t, mki;
+
+  rows = dest->rows;
+  columns = dest->columns;
+
+  j = i;
+  sgn = 1;
+  t = 0;
+
+  for( k = i; k < rows; k++) {
+    mki = (XXDouble) fabs(dest->mat[k * columns + i]);
+    if(mki > t) {
+      t = mki;
+      j = k;
+    }
+  }
+
+  if(j > i) {
+    XXSwapRows(dest, i, j);             /* swap matrix rows   */
+    XXSwapRows(p, i, j);                /* swap indices       */
+    sgn = -sgn;                         /* change sign of det */
+  }
+  return sgn;
@@ -164,38 +163,36 @@
-XXDouble XXDecompose (XXMatrix *dest, XXMatrix *p)
-{
-	XXDouble det, piv, mult;
-	XXInteger i, j, k, rows, columns, sgn;
-
-	rows = dest->rows;
-	columns = dest->columns;
-
-	det = 1.0;
-	for( i = 0; i < rows; i++)
-	{
-		sgn = XXPivot(dest, p, i);
-		piv = dest->mat[i*columns+i];
-		det *= sgn * piv;
-
-		if( det == 0.0 )
-		{
-			/* no solution is possible for this matrix.
-			 * so inform the caller by returning this determinant.
-			 */
-			return 0.0;
-		}
-
-		for( j = i+1 ; j < rows; j++)
-			dest->mat[i*columns+j] /= piv;
-
-		for( j = i+1 ; j < rows ; j++)
-		{
-			mult = dest->mat[j*columns+i];
-			if( mult != 0.0 )
-			{
-				for( k = i+1 ; k < rows; k++)
-					dest->mat[j*columns+k] -= mult * dest->mat[i*columns+k];
-			}
-		}
-
-	}
-	return det;
+XXDouble XXDecompose(XXMatrix *dest, XXMatrix *p)
+{
+  XXDouble det, piv, mult;
+  XXInteger i, j, k, rows, columns, sgn;
+
+  rows = dest->rows;
+  columns = dest->columns;
+
+  det = 1.0;
+  for( i = 0; i < rows; i++) {
+    sgn = XXPivot(dest, p, i);
+    piv = dest->mat[i * columns + i];
+    det *= sgn * piv;
+
+    if(det == 0.0) {
+                        /* no solution is possible for this matrix.
+                         * so inform the caller by returning this determinant.
+                         */
+      return 0.0;
+    }
+
+    for( j = i + 1 ; j < rows; j++) {
+      dest->mat[i * columns + j] /= piv;
+    }
+
+    for( j = i + 1 ; j < rows ; j++) {
+      mult = dest->mat[j * columns + i];
+      if(mult != 0.0) {
+        for( k = i + 1 ; k < rows; k++) {
+          dest->mat[j * columns + k] -= mult * dest->mat[i * columns + k];
+        }
+      }
+    }
+
+  }
+  return det;
@@ -208,24 +205,25 @@
-XXDouble XXCrout1 (XXMatrix *dest, XXMatrix *v, XXDouble *workarray)
-{
-	XXMatrix p;
-	XXDouble det;
-	XXDouble *permwork;
-
-	p.rows = dest->rows;
-	p.columns = 1;
-	p.mat = workarray;
-	XXIndex(&p);                    /* create p = [0,1,2, ...., rows]         */
-	det = XXDecompose(dest, &p);    /* this changes destination matrix itself.*/
-
-	/* if the determinant is zero there is no solution possible.
-	 * so return this determinant so that the caller is informed about
-	 * this fact.
-	 */
-	if( det == 0.0)
-		return 0.0;
-
-	/* use the offset in the workarray as work array for the permute operation */
-	permwork = &workarray[p.rows];
-	XXPermute(v, &p, permwork);     /* swap the vector v using the swap vector p */
-	XXSubstitute(dest, v);
-	return det;
+XXDouble XXCrout1(XXMatrix *dest, XXMatrix *v, XXDouble *workarray)
+{
+  XXMatrix p;
+  XXDouble det;
+  XXDouble *permwork;
+
+  p.rows = dest->rows;
+  p.columns = 1;
+  p.mat = workarray;
+  XXIndex(&p);                          /* create p = [0,1,2, ...., rows]         */
+  det = XXDecompose(dest, &p);          /* this changes destination matrix itself.*/
+
+        /* if the determinant is zero there is no solution possible.
+         * so return this determinant so that the caller is informed about
+         * this fact.
+         */
+  if(det == 0.0) {
+    return 0.0;
+  }
+
+        /* use the offset in the workarray as work array for the permute operation */
+  permwork = &workarray[p.rows];
+  XXPermute(v, &p, permwork);           /* swap the vector v using the swap vector p */
+  XXSubstitute(dest, v);
+  return det;
@@ -241,7 +239,8 @@
-XXDouble XXCrout2 (XXMatrix *dest, XXMatrix *CroutMat,
-			 XXMatrix *x, XXMatrix *y, XXDouble *workarray)
-{
-	/* preserve memory */
-	XXMatrixMov(CroutMat, dest);
-	XXMatrixMov(x, y);
-	return XXCrout1(CroutMat, x, workarray);
+XXDouble XXCrout2(
+  XXMatrix *dest, XXMatrix *CroutMat,
+  XXMatrix *x, XXMatrix *y, XXDouble *workarray)
+{
+        /* preserve memory */
+  XXMatrixMov(CroutMat, dest);
+  XXMatrixMov(x, y);
+  return XXCrout1(CroutMat, x, workarray);
@@ -256,63 +255,61 @@
-XXDouble XXInverse (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
-{
-	/* wrapper matrices for the workarray */
-	XXMatrix newMatrix;
-	XXMatrix p;
-	XXMatrix t;
-	XXMatrix tempV;
-	XXInteger i, offset, rows, columns;
-	XXDouble det;
-
-	rows = mat_source->rows;
-	columns = mat_source->columns;
-
-	/* map the workarray onto the the matrix objects */
-	newMatrix.rows = rows;
-	newMatrix.columns = columns;
-	newMatrix.mat = workarray;
-	offset = rows * columns;
-
-	p.rows = rows;
-	p.columns = 1;
-	p.mat = &workarray[offset];
-	offset += rows;
-
-	t.rows = rows;
-	t.columns = columns;
-	t.mat = &workarray[offset];
-	offset += rows * columns;
-
-	tempV.rows = 1;
-	tempV.columns = columns;
-	tempV.mat = &workarray[offset];
-	offset += columns;
-
-	/* and do the calculations */
-	XXIndex(&p);
-	XXMatrixEye(&t);
-
-	/* make a copy of the source, since we are going to chenge this */
-	XXMatrixMov(&newMatrix, mat_source);
-	det = XXDecompose(&newMatrix, &p);
-	if( det == 0.0 )
-	{
-		/* there is no inverse of the matrix */
-		return 0.0;
-	}
-
-	/* treat col vectors as row vectors. */
-	for( i = 0; i < rows; i++)
-	{
-		XXMatrixGetRow(&tempV, &t, i);
-
-		/* workarray here size of v */
-		XXPermute( &tempV, &p, &workarray[offset]);
-		XXSubstitute(&newMatrix, &tempV );
-
-		XXMatrixSetRow(&t, &tempV, i);
-	}
-
-	/* transpose to col vectors to our final destination */
-	XXMatrixTranspose(mat_dest, &t);
-
-	return det;
+XXDouble XXInverse(XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
+{
+        /* wrapper matrices for the workarray */
+  XXMatrix newMatrix;
+  XXMatrix p;
+  XXMatrix t;
+  XXMatrix tempV;
+  XXInteger i, offset, rows, columns;
+  XXDouble det;
+
+  rows = mat_source->rows;
+  columns = mat_source->columns;
+
+        /* map the workarray onto the the matrix objects */
+  newMatrix.rows = rows;
+  newMatrix.columns = columns;
+  newMatrix.mat = workarray;
+  offset = rows * columns;
+
+  p.rows = rows;
+  p.columns = 1;
+  p.mat = &workarray[offset];
+  offset += rows;
+
+  t.rows = rows;
+  t.columns = columns;
+  t.mat = &workarray[offset];
+  offset += rows * columns;
+
+  tempV.rows = 1;
+  tempV.columns = columns;
+  tempV.mat = &workarray[offset];
+  offset += columns;
+
+        /* and do the calculations */
+  XXIndex(&p);
+  XXMatrixEye(&t);
+
+        /* make a copy of the source, since we are going to chenge this */
+  XXMatrixMov(&newMatrix, mat_source);
+  det = XXDecompose(&newMatrix, &p);
+  if(det == 0.0) {
+                /* there is no inverse of the matrix */
+    return 0.0;
+  }
+
+        /* treat col vectors as row vectors. */
+  for( i = 0; i < rows; i++) {
+    XXMatrixGetRow(&tempV, &t, i);
+
+                /* workarray here size of v */
+    XXPermute(&tempV, &p, &workarray[offset]);
+    XXSubstitute(&newMatrix, &tempV);
+
+    XXMatrixSetRow(&t, &tempV, i);
+  }
+
+        /* transpose to col vectors to our final destination */
+  XXMatrixTranspose(mat_dest, &t);
+
+  return det;
@@ -325,27 +322,27 @@
-XXDouble XXMatrixDeterminant (XXMatrix *mat_source, XXDouble *workarray)
-{
-	/* wrapper matrices for the workarray */
-	XXMatrix newMatrix;
-	XXMatrix p;
-	XXInteger rows, columns;
-
-	rows = mat_source->rows;
-	columns = mat_source->columns;
-
-	/* map the workarray onto the the matrix objects */
-	newMatrix.rows = rows;
-	newMatrix.columns = columns;
-	newMatrix.mat = workarray;
-
-	p.rows = rows;
-	p.columns = 1;
-	p.mat = &workarray[rows * columns];
-
-	/* and do the calculations */
-	XXIndex(&p);
-
-	/* make a copy of the source, since we are going to chenge this */
-	XXMatrixMov(&newMatrix, mat_source);
-
-	/* and return the determinant */
-	return XXDecompose(&newMatrix, &p);
+XXDouble XXMatrixDeterminant(XXMatrix *mat_source, XXDouble *workarray)
+{
+        /* wrapper matrices for the workarray */
+  XXMatrix newMatrix;
+  XXMatrix p;
+  XXInteger rows, columns;
+
+  rows = mat_source->rows;
+  columns = mat_source->columns;
+
+        /* map the workarray onto the the matrix objects */
+  newMatrix.rows = rows;
+  newMatrix.columns = columns;
+  newMatrix.mat = workarray;
+
+  p.rows = rows;
+  p.columns = 1;
+  p.mat = &workarray[rows * columns];
+
+        /* and do the calculations */
+  XXIndex(&p);
+
+        /* make a copy of the source, since we are going to chenge this */
+  XXMatrixMov(&newMatrix, mat_source);
+
+        /* and return the determinant */
+  return XXDecompose(&newMatrix, &p);
@@ -359,3 +356,3 @@
-void XXMatrixInverse (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
-{
-	XXInverse(mat_dest, mat_source, workarray);
+void XXMatrixInverse(XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
+{
+  XXInverse(mat_dest, mat_source, workarray);
@@ -369,19 +366,22 @@
-void XXMatrixDiv (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2, XXDouble *workarray)
-{
-	XXMatrix workMatrix;
-	XXInteger offset;
-	XXDouble det;
-
-	workMatrix.rows = mat_source2->rows;
-	workMatrix.columns = mat_source2->columns;
-	workMatrix.mat = workarray;
-	offset = workMatrix.rows * workMatrix.columns;
-
-	/* take the inverse and put it in our workmatrix */
-	det = XXInverse(&workMatrix, mat_source2, &workarray[offset]);
-
-	if( det == 0.0 )
-		return;
-
-	/* multiply source 1 with the workMatrix(=inverse(source1)) */
-	XXMatrixMul(mat_dest, mat_source1, &workMatrix);
+void XXMatrixDiv(
+  XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2,
+  XXDouble *workarray)
+{
+  XXMatrix workMatrix;
+  XXInteger offset;
+  XXDouble det;
+
+  workMatrix.rows = mat_source2->rows;
+  workMatrix.columns = mat_source2->columns;
+  workMatrix.mat = workarray;
+  offset = workMatrix.rows * workMatrix.columns;
+
+        /* take the inverse and put it in our workmatrix */
+  det = XXInverse(&workMatrix, mat_source2, &workarray[offset]);
+
+  if(det == 0.0) {
+    return;
+  }
+
+        /* multiply source 1 with the workMatrix(=inverse(source1)) */
+  XXMatrixMul(mat_dest, mat_source1, &workMatrix);
@@ -393,14 +393,13 @@
-void XXMatrixScalarDiv (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
-{
-	XXDouble *d, *s1;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	i = mat_dest->rows * mat_dest->columns;
-
-	while (i)
-	{
-		(*d) = (*s1) / s2;
-		d++; s1++; i--;
-	}
+void XXMatrixScalarDiv(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
+{
+  XXDouble *d, *s1;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  i = mat_dest->rows * mat_dest->columns;
+
+  while (i) {
+    (*d) = (*s1) / s2;
+    d++; s1++; i--;
+  }
@@ -414,16 +413,17 @@
-void XXScalarMatrixDiv (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2, XXDouble *workarray)
-{
-	XXDouble det;
-	XXInteger i, size;
-	det = XXInverse(mat_dest, mat_source2, workarray);
-
-	/* here you could do something with the det result */
-	if( det == 0.0 )
-		return;
-
-	/* and multiply by the scalar */
-	size = mat_dest->rows * mat_dest->columns;
-	for( i = 0; i < size; i++)
-		mat_dest->mat[i] *= s1;
-}
-
+void XXScalarMatrixDiv(XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2, XXDouble *workarray)
+{
+  XXDouble det;
+  XXInteger i, size;
+  det = XXInverse(mat_dest, mat_source2, workarray);
+
+        /* here you could do something with the det result */
+  if(det == 0.0) {
+    return;
+  }
+
+        /* and multiply by the scalar */
+  size = mat_dest->rows * mat_dest->columns;
+  for( i = 0; i < size; i++) {
+    mat_dest->mat[i] *= s1;
+  }
+}
]]></failure>
  </testcase>
  <testcase
    name="common/xxinverse.h"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 31 lines"><![CDATA[--- common/xxinverse.h
+++ common/xxinverse.h.uncrustify
@@ -2 +2 @@
- * This file is generated by 20-sim ANSI-C Code Generator  
+ * This file is generated by 20-sim ANSI-C Code Generator
@@ -10 +10 @@
- *  user:  Universiteit Twente 
+ *  user:  Universiteit Twente
@@ -23,9 +23,11 @@
-void XXIndex (XXMatrix *v);
-void XXPermute (XXMatrix *v, XXMatrix *p, XXDouble *workarray);
-void XXSubstitute (XXMatrix *dest, XXMatrix *v);
-void XXSwapRows (XXMatrix *dest, XXInteger row1, XXInteger row2);
-XXInteger XXPivot (XXMatrix *dest, XXMatrix *p, XXInteger i);
-XXDouble XXDecompose (XXMatrix *dest, XXMatrix *p);
-XXDouble XXCrout1 (XXMatrix *dest, XXMatrix *v, XXDouble *workarray);
-XXDouble XXCrout2 (XXMatrix *dest, XXMatrix *CroutMat, XXMatrix *x, XXMatrix *y, XXDouble *workarray);
-XXDouble XXInverse (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray);
+void XXIndex(XXMatrix *v);
+void XXPermute(XXMatrix *v, XXMatrix *p, XXDouble *workarray);
+void XXSubstitute(XXMatrix *dest, XXMatrix *v);
+void XXSwapRows(XXMatrix *dest, XXInteger row1, XXInteger row2);
+XXInteger XXPivot(XXMatrix *dest, XXMatrix *p, XXInteger i);
+XXDouble XXDecompose(XXMatrix *dest, XXMatrix *p);
+XXDouble XXCrout1(XXMatrix *dest, XXMatrix *v, XXDouble *workarray);
+XXDouble XXCrout2(
+  XXMatrix *dest, XXMatrix *CroutMat, XXMatrix *x, XXMatrix *y,
+  XXDouble *workarray);
+XXDouble XXInverse(XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray);
@@ -34 +35,0 @@
-
]]></failure>
  </testcase>
  <testcase
    name="common/xxmatrix.cpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 2124 lines"><![CDATA[--- common/xxmatrix.cpp
+++ common/xxmatrix.cpp.uncrustify
@@ -28,4 +28,4 @@
-void XXMatrixMov (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	const XXInteger size = mat_dest->rows * mat_dest->columns;
-	memcpy(mat_dest->mat, mat_source->mat, size * sizeof(XXDouble));
+void XXMatrixMov(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  const XXInteger size = mat_dest->rows * mat_dest->columns;
+  memcpy(mat_dest->mat, mat_source->mat, size * sizeof(XXDouble));
@@ -37,15 +37,14 @@
-void XXMatrixScalarMov (XXMatrix *mat_dest, XXDouble s)
-{
-	XXDouble *d;
-	XXInteger i;
-
-	d = mat_dest->mat;
-
-	/* use a while loop because it is efficient! */
-	i = mat_dest->rows * mat_dest->columns;
-	while(i)
-	{
-		(*d) = s;
-		d++;
-		i--;
-	}
+void XXMatrixScalarMov(XXMatrix *mat_dest, XXDouble s)
+{
+  XXDouble *d;
+  XXInteger i;
+
+  d = mat_dest->mat;
+
+        /* use a while loop because it is efficient! */
+  i = mat_dest->rows * mat_dest->columns;
+  while(i) {
+    (*d) = s;
+    d++;
+    i--;
+  }
@@ -58,6 +57,6 @@
-void XXMatrixGetRow (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row)
-{
-	const XXInteger size = mat_source->columns;
-
-	/* do it with a memcpy, since it is linear memory */
-	memcpy(mat_dest->mat, &mat_source->mat[size*row], size * sizeof(XXDouble));
+void XXMatrixGetRow(XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row)
+{
+  const XXInteger size = mat_source->columns;
+
+        /* do it with a memcpy, since it is linear memory */
+  memcpy(mat_dest->mat, &mat_source->mat[size * row], size * sizeof(XXDouble));
@@ -70,6 +69,6 @@
-void XXMatrixSetRow (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row)
-{
-	const XXInteger size = mat_source->columns;
-
-	/* do it with a memcpy, since it is linear memory */
-	memcpy(&mat_dest->mat[size*row], mat_source->mat, size * sizeof(XXDouble));
+void XXMatrixSetRow(XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row)
+{
+  const XXInteger size = mat_source->columns;
+
+        /* do it with a memcpy, since it is linear memory */
+  memcpy(&mat_dest->mat[size * row], mat_source->mat, size * sizeof(XXDouble));
@@ -82,10 +81,9 @@
-void XXMatrixGetColumn (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column)
-{
-	XXInteger i;
-	const XXInteger rows = mat_dest->rows;
-	const XXInteger columns = mat_dest->columns;
-
-	for( i = 0; i < rows; i++)
-	{
-		mat_dest->mat[i] = mat_source->mat[columns * i + column];
-	}
+void XXMatrixGetColumn(XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column)
+{
+  XXInteger i;
+  const XXInteger rows = mat_dest->rows;
+  const XXInteger columns = mat_dest->columns;
+
+  for( i = 0; i < rows; i++) {
+    mat_dest->mat[i] = mat_source->mat[columns * i + column];
+  }
@@ -98,10 +96,9 @@
-void XXMatrixSetColumn (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column)
-{
-	XXInteger i;
-	const XXInteger rows = mat_dest->rows;
-	const XXInteger columns = mat_dest->columns;
-
-	for( i = 0; i < rows; i++)
-	{
-		mat_dest->mat[columns * i + column] = mat_source->mat[i];
-	}
+void XXMatrixSetColumn(XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column)
+{
+  XXInteger i;
+  const XXInteger rows = mat_dest->rows;
+  const XXInteger columns = mat_dest->columns;
+
+  for( i = 0; i < rows; i++) {
+    mat_dest->mat[columns * i + column] = mat_source->mat[i];
+  }
@@ -114,15 +111,14 @@
-void XXMatrixDiag (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	XXInteger i;
-	const XXInteger rows = mat_dest->rows;
-	const XXInteger columns = mat_dest->columns;
-
-	/* first set everything zero */
-	memset(mat_dest->mat, 0, rows * columns * sizeof(XXDouble));
-
-	/* and loop to set the diagonal values */
-	for( i = 0; i < rows; i++)
-	{
-		/* set the diagonal value */
-		mat_dest->mat[columns*i+i] = mat_source->mat[i];
-	}
+void XXMatrixDiag(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  XXInteger i;
+  const XXInteger rows = mat_dest->rows;
+  const XXInteger columns = mat_dest->columns;
+
+        /* first set everything zero */
+  memset(mat_dest->mat, 0, rows * columns * sizeof(XXDouble));
+
+        /* and loop to set the diagonal values */
+  for( i = 0; i < rows; i++) {
+                /* set the diagonal value */
+    mat_dest->mat[columns * i + i] = mat_source->mat[i];
+  }
@@ -133,19 +129,18 @@
-void XXMatrixAdd (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXDouble *d;
-	XXDouble *s1;
-	XXDouble *s2;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	/* use a while loop because it is efficient! */
-	i = mat_dest->rows * mat_dest->columns;
-	while(i)
-	{
-		(*d) = (*s1) + (*s2);
-		d++;s1++;s2++;
-		i--;
-	}
+void XXMatrixAdd(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXDouble *d;
+  XXDouble *s1;
+  XXDouble *s2;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+        /* use a while loop because it is efficient! */
+  i = mat_dest->rows * mat_dest->columns;
+  while(i) {
+    (*d) = (*s1) + (*s2);
+    d++;s1++;s2++;
+    i--;
+  }
@@ -157,17 +152,16 @@
-void XXMatrixScalarAdd (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
-{
-	XXDouble *d;
-	XXDouble *s1;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-
-	/* use a while loop because it is efficient! */
-	i = mat_dest->rows * mat_dest->columns;
-	while(i)
-	{
-		(*d) = (*s1) + s2;
-		d++;s1++;
-		i--;
-	}
+void XXMatrixScalarAdd(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
+{
+  XXDouble *d;
+  XXDouble *s1;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+
+        /* use a while loop because it is efficient! */
+  i = mat_dest->rows * mat_dest->columns;
+  while(i) {
+    (*d) = (*s1) + s2;
+    d++;s1++;
+    i--;
+  }
@@ -179,17 +173,16 @@
-void XXScalarMatrixAdd (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
-{
-	XXDouble *d;
-	XXDouble *s2;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s2 = mat_source2->mat;
-
-	/* use a while loop because it is efficient! */
-	i = mat_dest->rows * mat_dest->columns;
-	while(i)
-	{
-		(*d) = s1 + (*s2);
-		d++;s2++;
-		i--;
-	}
+void XXScalarMatrixAdd(XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
+{
+  XXDouble *d;
+  XXDouble *s2;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s2 = mat_source2->mat;
+
+        /* use a while loop because it is efficient! */
+  i = mat_dest->rows * mat_dest->columns;
+  while(i) {
+    (*d) = s1 + (*s2);
+    d++;s2++;
+    i--;
+  }
@@ -201,11 +194,10 @@
-void XXScalarScalarAdd (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
-{
-	XXDouble value;
-	XXInteger i;
-	const XXInteger size = mat_dest->rows * mat_dest->columns;
-
-	value = s1 + s2;
-	for(i = 0; i < size; i++)
-	{
-		mat_dest->mat[i] = value;
-	}
+void XXScalarScalarAdd(XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
+{
+  XXDouble value;
+  XXInteger i;
+  const XXInteger size = mat_dest->rows * mat_dest->columns;
+
+  value = s1 + s2;
+  for(i = 0; i < size; i++) {
+    mat_dest->mat[i] = value;
+  }
@@ -217,19 +209,18 @@
-void XXMatrixSub (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXDouble *d;
-	XXDouble *s1;
-	XXDouble *s2;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	/* use a while loop because it is efficient! */
-	i = mat_dest->rows * mat_dest->columns;
-	while(i)
-	{
-		(*d) = (*s1) - (*s2);
-		d++;s1++;s2++;
-		i--;
-	}
+void XXMatrixSub(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXDouble *d;
+  XXDouble *s1;
+  XXDouble *s2;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+        /* use a while loop because it is efficient! */
+  i = mat_dest->rows * mat_dest->columns;
+  while(i) {
+    (*d) = (*s1) - (*s2);
+    d++;s1++;s2++;
+    i--;
+  }
@@ -241,17 +232,16 @@
-void XXMatrixScalarSub (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
-{
-	XXDouble *d;
-	XXDouble *s1;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-
-	/* use a while loop because it is efficient! */
-	i = mat_dest->rows * mat_dest->columns;
-	while(i)
-	{
-		(*d) = (*s1) - s2;
-		d++;s1++;
-		i--;
-	}
+void XXMatrixScalarSub(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
+{
+  XXDouble *d;
+  XXDouble *s1;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+
+        /* use a while loop because it is efficient! */
+  i = mat_dest->rows * mat_dest->columns;
+  while(i) {
+    (*d) = (*s1) - s2;
+    d++;s1++;
+    i--;
+  }
@@ -263,17 +253,16 @@
-void XXScalarMatrixSub (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
-{
-	XXDouble *d;
-	XXDouble *s2;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s2 = mat_source2->mat;
-
-	/* use a while loop because it is efficient! */
-	i = mat_dest->rows * mat_dest->columns;
-	while(i)
-	{
-		(*d) = s1 - (*s2);
-		d++;s2++;
-		i--;
-	}
+void XXScalarMatrixSub(XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
+{
+  XXDouble *d;
+  XXDouble *s2;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s2 = mat_source2->mat;
+
+        /* use a while loop because it is efficient! */
+  i = mat_dest->rows * mat_dest->columns;
+  while(i) {
+    (*d) = s1 - (*s2);
+    d++;s2++;
+    i--;
+  }
@@ -285,11 +274,10 @@
-void XXScalarScalarSub (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
-{
-	XXDouble value;
-	XXInteger i;
-	const XXInteger size = mat_dest->rows * mat_dest->columns;
-
-	value = s1 - s2;
-	for(i = 0; i < size; i++)
-	{
-		mat_dest->mat[i] = value;
-	}
+void XXScalarScalarSub(XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
+{
+  XXDouble value;
+  XXInteger i;
+  const XXInteger size = mat_dest->rows * mat_dest->columns;
+
+  value = s1 - s2;
+  for(i = 0; i < size; i++) {
+    mat_dest->mat[i] = value;
+  }
@@ -301,48 +289,45 @@
-void XXMatrixMul (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	/* do the actual multiplication (code needs no documentation, obviously) */
-	XXInteger destIndex1, destIndex2, s1Index;
-	XXDouble *d, *s1, *s2;
-	XXDouble *d2, *s11, *s22;
-	XXInteger i, j, k;
-	XXInteger cMatSource1m;
-	XXInteger cMatSource2m;
-	XXInteger cMatSource2n;
-	XXInteger cMatDestn, cMatDestm;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-	cMatSource1m = mat_source1->columns;
-	cMatSource2m = mat_source2->columns;
-	cMatSource2n = mat_source2->rows;
-	cMatDestn = mat_dest->rows;
-	cMatDestm = mat_dest->columns;
-
-	i = 0;
-
-	while (i < cMatDestn)
-	{
-		destIndex1 = cMatDestm * i;
-		s1Index = i * cMatSource1m;
-
-		j = 0;
-		while (j < cMatDestm)
-		{
-			destIndex2 = destIndex1+j;
-			d2 = d + destIndex2;
-			*d2 = 0.0;
-			s11 = s1 + s1Index;
-			s22 = s2 + j;
-			k = cMatSource2n;
-			while (k)
-			{
-				(*d2) += (*s11) * (*s22);
-				s11++;
-				k--;
-				s22 += cMatSource2m;
-			}
-			j++;
-		}
-		i++;
-	}
+void XXMatrixMul(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+        /* do the actual multiplication (code needs no documentation, obviously) */
+  XXInteger destIndex1, destIndex2, s1Index;
+  XXDouble *d, *s1, *s2;
+  XXDouble *d2, *s11, *s22;
+  XXInteger i, j, k;
+  XXInteger cMatSource1m;
+  XXInteger cMatSource2m;
+  XXInteger cMatSource2n;
+  XXInteger cMatDestn, cMatDestm;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+  cMatSource1m = mat_source1->columns;
+  cMatSource2m = mat_source2->columns;
+  cMatSource2n = mat_source2->rows;
+  cMatDestn = mat_dest->rows;
+  cMatDestm = mat_dest->columns;
+
+  i = 0;
+
+  while (i < cMatDestn) {
+    destIndex1 = cMatDestm * i;
+    s1Index = i * cMatSource1m;
+
+    j = 0;
+    while (j < cMatDestm) {
+      destIndex2 = destIndex1 + j;
+      d2 = d + destIndex2;
+      *d2 = 0.0;
+      s11 = s1 + s1Index;
+      s22 = s2 + j;
+      k = cMatSource2n;
+      while (k) {
+        (*d2) += (*s11) * (*s22);
+        s11++;
+        k--;
+        s22 += cMatSource2m;
+      }
+      j++;
+    }
+    i++;
+  }
@@ -354,14 +339,13 @@
-void XXMatrixScalarMul (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
-{
-	XXDouble *d, *s1;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	i = mat_dest->rows * mat_dest->columns;
-
-	while (i)
-	{
-		(*d) = (*s1) * s2;
-		d++; s1++; i--;
-	}
+void XXMatrixScalarMul(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
+{
+  XXDouble *d, *s1;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  i = mat_dest->rows * mat_dest->columns;
+
+  while (i) {
+    (*d) = (*s1) * s2;
+    d++; s1++; i--;
+  }
@@ -373,14 +357,13 @@
-void XXScalarMatrixMul (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
-{
-	XXDouble *d, *s2;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s2 = mat_source2->mat;
-	i = mat_dest->rows * mat_dest->columns;
-
-	while (i)
-	{
-		(*d) = s1 * (*s2);
-		d++; s2++; i--;
-	}
+void XXScalarMatrixMul(XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
+{
+  XXDouble *d, *s2;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s2 = mat_source2->mat;
+  i = mat_dest->rows * mat_dest->columns;
+
+  while (i) {
+    (*d) = s1 * (*s2);
+    d++; s2++; i--;
+  }
@@ -392,12 +375,11 @@
-void XXScalarScalarMul (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
-{
-	XXDouble value;
-	XXInteger i;
-	const XXInteger size = mat_dest->rows * mat_dest->columns;
-
-	value = s1 * s2;
-
-	for(i = 0; i < size; i++)
-	{
-		mat_dest->mat[i] = value;
-	}
+void XXScalarScalarMul(XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
+{
+  XXDouble value;
+  XXInteger i;
+  const XXInteger size = mat_dest->rows * mat_dest->columns;
+
+  value = s1 * s2;
+
+  for(i = 0; i < size; i++) {
+    mat_dest->mat[i] = value;
+  }
@@ -410,10 +392,9 @@
-void XXScalarMatrixMatrixMul (XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXInteger i;
-	const XXInteger size = mat_source1->columns;
-
-	*dest = 0.0;
-	for(i = 0; i < size; i++)
-	{
-		*dest += mat_source1->mat[i] * mat_source2->mat[i];
-	}
+void XXScalarMatrixMatrixMul(XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXInteger i;
+  const XXInteger size = mat_source1->columns;
+
+  *dest = 0.0;
+  for(i = 0; i < size; i++) {
+    *dest += mat_source1->mat[i] * mat_source2->mat[i];
+  }
@@ -425,11 +406,10 @@
-void XXScalarScalarDiv (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
-{
-	XXDouble value;
-	XXInteger i;
-	const XXInteger size = mat_dest->rows * mat_dest->columns;
-
-	value = s1 / s2;
-	for(i = 0; i < size; i++)
-	{
-		mat_dest->mat[i] = value;
-	}
+void XXScalarScalarDiv(XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
+{
+  XXDouble value;
+  XXInteger i;
+  const XXInteger size = mat_dest->rows * mat_dest->columns;
+
+  value = s1 / s2;
+  for(i = 0; i < size; i++) {
+    mat_dest->mat[i] = value;
+  }
@@ -441,14 +421,13 @@
-void XXMatrixInv (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	XXDouble *d, *s;
-	XXInteger i;
-
-	d = mat_dest->mat;
-	s = mat_source->mat;
-	i = mat_dest->rows * mat_dest->columns;
-
-	while (i)
-	{
-		(*d) = -(*s);
-		d++; s++; i--;
-	}
+void XXMatrixInv(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  XXDouble *d, *s;
+  XXInteger i;
+
+  d = mat_dest->mat;
+  s = mat_source->mat;
+  i = mat_dest->rows * mat_dest->columns;
+
+  while (i) {
+    (*d) = -(*s);
+    d++; s++; i--;
+  }
@@ -460,17 +439,15 @@
-void XXMatrixTranspose (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	XXDouble *d, *s;
-	XXInteger i, j;
-	const XXInteger rows = mat_dest->rows;
-	const XXInteger columns = mat_dest->columns;
-
-	d = mat_dest->mat;
-	s = mat_source->mat;
-
-	for(i = 0; i < rows; i++)
-	{
-		for(j = 0; j < columns; j++)
-		{
-			d[i * columns + j] = s[ j * rows + i];
-		}
-	}
+void XXMatrixTranspose(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  XXDouble *d, *s;
+  XXInteger i, j;
+  const XXInteger rows = mat_dest->rows;
+  const XXInteger columns = mat_dest->columns;
+
+  d = mat_dest->mat;
+  s = mat_source->mat;
+
+  for(i = 0; i < rows; i++) {
+    for(j = 0; j < columns; j++) {
+      d[i * columns + j] = s[j * rows + i];
+    }
+  }
@@ -481,14 +458,13 @@
-void XXMatrixMulElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXInteger i;
-	XXDouble *d, *s1, *s2;
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	i = mat_source1->rows * mat_source1->columns;
-	while(i)
-	{
-		*d = (*s1) * (*s2);
-		d++; s1++; s2++; i--;
-	}
+void XXMatrixMulElement(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXInteger i;
+  XXDouble *d, *s1, *s2;
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+  i = mat_source1->rows * mat_source1->columns;
+  while(i) {
+    *d = (*s1) * (*s2);
+    d++; s1++; s2++; i--;
+  }
@@ -499,14 +475,13 @@
-void XXMatrixDivElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXInteger i;
-	XXDouble *d, *s1, *s2;
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	i = mat_source1->rows * mat_source1->columns;
-	while(i)
-	{
-		*d = (*s1) / (*s2);
-		d++; s1++; s2++; i--;
-	}
+void XXMatrixDivElement(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXInteger i;
+  XXDouble *d, *s1, *s2;
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+  i = mat_source1->rows * mat_source1->columns;
+  while(i) {
+    *d = (*s1) / (*s2);
+    d++; s1++; s2++; i--;
+  }
@@ -518,13 +493,12 @@
-void XXMatrixScalarPowElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble scalar_source2)
-{
-	XXInteger i;
-	XXDouble *d, *s1;
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-
-	i = mat_source1->rows * mat_source1->columns;
-	while(i)
-	{
-		*d = pow((*s1), scalar_source2);
-		d++; s1++; i--;
-	}
+void XXMatrixScalarPowElement(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble scalar_source2)
+{
+  XXInteger i;
+  XXDouble *d, *s1;
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+
+  i = mat_source1->rows * mat_source1->columns;
+  while(i) {
+    *d = pow((*s1), scalar_source2);
+    d++; s1++; i--;
+  }
@@ -536,14 +510,13 @@
-void XXMatrixPowElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXInteger i;
-	XXDouble *d, *s1, *s2;
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	i = mat_source1->rows * mat_source1->columns;
-	while(i)
-	{
-		*d = pow((*s1),(*s2));
-		d++; s1++; s2++; i--;
-	}
+void XXMatrixPowElement(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXInteger i;
+  XXDouble *d, *s1, *s2;
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+  i = mat_source1->rows * mat_source1->columns;
+  while(i) {
+    *d = pow((*s1), (*s2));
+    d++; s1++; s2++; i--;
+  }
@@ -555,9 +528,9 @@
-void XXMatrixMovRelAbs (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
-{
-	/* source 1 is one based, we are zero based
-	   leave some room for small variances. */
-	XXInteger linIndex;
-
-	linIndex = (XXInteger)(s1 - 0.9);
-
-	mat_dest->mat[linIndex] = s2;
+void XXMatrixMovRelAbs(XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
+{
+        /* source 1 is one based, we are zero based
+           leave some room for small variances. */
+  XXInteger linIndex;
+
+  linIndex = (XXInteger)(s1 - 0.9);
+
+  mat_dest->mat[linIndex] = s2;
@@ -570,9 +543,9 @@
-void XXMatrixMovAbsRel (XXDouble *dest, XXMatrix *mat_source1, XXDouble s2)
-{
-	/* source 2 is one based, we are zero based
-	  leave some room for small variances. */
-	XXInteger linIndex;
-
-	linIndex = (XXInteger)(s2 - 0.9);
-
-	*dest = mat_source1->mat[linIndex];
+void XXMatrixMovAbsRel(XXDouble *dest, XXMatrix *mat_source1, XXDouble s2)
+{
+        /* source 2 is one based, we are zero based
+          leave some room for small variances. */
+  XXInteger linIndex;
+
+  linIndex = (XXInteger)(s2 - 0.9);
+
+  *dest = mat_source1->mat[linIndex];
@@ -584,19 +557,19 @@
-void XXMatrixMinimum (XXDouble *dest, XXMatrix *mat_source)
-{
-	XXDouble *s;
-	XXInteger i;
-
-	s = mat_source->mat;
-	*dest = (*s);
-
-	/* go to the second element */
-	s++;
-
-	i = mat_source->rows * mat_source->columns - 1;
-	while(i)
-	{
-		if( (*s) < (*dest) )
-			*dest = (*s);
-		s++;
-		i--;
-	}
+void XXMatrixMinimum(XXDouble *dest, XXMatrix *mat_source)
+{
+  XXDouble *s;
+  XXInteger i;
+
+  s = mat_source->mat;
+  *dest = (*s);
+
+        /* go to the second element */
+  s++;
+
+  i = mat_source->rows * mat_source->columns - 1;
+  while(i) {
+    if( (*s) < (*dest) ) {
+      *dest = (*s);
+    }
+    s++;
+    i--;
+  }
@@ -608,19 +581,19 @@
-void XXMatrixMaximum (XXDouble *dest, XXMatrix *mat_source)
-{
-	XXDouble *s;
-	XXInteger i;
-
-	s = mat_source->mat;
-	*dest = (*s);
-
-	/* go to the second element */
-	s++;
-	i = mat_source->rows * mat_source->columns - 1;
-
-	while(i)
-	{
-		if( (*s) > (*dest) )
-			*dest = (*s);
-		s++;
-		i--;
-	}
+void XXMatrixMaximum(XXDouble *dest, XXMatrix *mat_source)
+{
+  XXDouble *s;
+  XXInteger i;
+
+  s = mat_source->mat;
+  *dest = (*s);
+
+        /* go to the second element */
+  s++;
+  i = mat_source->rows * mat_source->columns - 1;
+
+  while(i) {
+    if( (*s) > (*dest) ) {
+      *dest = (*s);
+    }
+    s++;
+    i--;
+  }
@@ -631,15 +604,14 @@
-void XXMatrixSum (XXDouble *dest, XXMatrix *mat_source)
-{
-	XXDouble *s;
-	XXInteger i;
-
-	s = mat_source->mat;
-	*dest = 0;
-	i = mat_source->rows * mat_source->columns;
-
-	while(i)
-	{
-		*dest += (*s);
-		s++;
-		i--;
-	}
+void XXMatrixSum(XXDouble *dest, XXMatrix *mat_source)
+{
+  XXDouble *s;
+  XXInteger i;
+
+  s = mat_source->mat;
+  *dest = 0;
+  i = mat_source->rows * mat_source->columns;
+
+  while(i) {
+    *dest += (*s);
+    s++;
+    i--;
+  }
@@ -651,20 +623,18 @@
-void XXMatrixEye (XXMatrix *mat_dest)
-{
-	XXInteger i;
-	XXDouble *d;
-
-	const XXInteger rows = mat_dest->rows;
-	const XXInteger columns = mat_dest->columns;
-	const XXInteger size = rows * columns;
-	d = mat_dest->mat;
-
-	/* first set everything to zero */
-	if( size > 0 )
-	{
-		memset(d, 0, size * sizeof(XXDouble));
-	}
-
-	for(i = 0; i < rows; i++)
-	{
-		d[i*(columns+1)] = 1.0;
-	}
+void XXMatrixEye(XXMatrix *mat_dest)
+{
+  XXInteger i;
+  XXDouble *d;
+
+  const XXInteger rows = mat_dest->rows;
+  const XXInteger columns = mat_dest->columns;
+  const XXInteger size = rows * columns;
+  d = mat_dest->mat;
+
+        /* first set everything to zero */
+  if(size > 0) {
+    memset(d, 0, size * sizeof(XXDouble));
+  }
+
+  for(i = 0; i < rows; i++) {
+    d[i * (columns + 1)] = 1.0;
+  }
@@ -681,42 +651,41 @@
-void XXMatrixPow (XXMatrix *mat_dest, XXMatrix *mat_source1,
-		  XXDouble s2, XXDouble *workarray)
-{
-	XXDouble abssrc2;
-	XXInteger i, pow_val, offset;
-	XXMatrix workMatrix;
-
-	abssrc2 = (XXDouble) fabs(s2);
-	pow_val = (XXInteger)(abssrc2  + 0.1);
-
-	/* map the work array on a local matrix */
-	workMatrix.columns = mat_dest->columns;
-	workMatrix.rows = mat_dest->rows;
-	workMatrix.mat = workarray;
-
-	/* first set the matrix to the eye value. */
-	XXMatrixEye(mat_dest);
-
-	/* keep multiplying the matrix with the source. */
-	for( i = 0; i < pow_val; i++ )
-	{
-		/* multiply the source with the destination to the work matrix */
-		XXMatrixMul(&workMatrix, mat_dest, mat_source1);
-
-		/* and copy the workmatrix to the destination */
-		XXMatrixMov(mat_dest, &workMatrix);
-	}
-
-	if( s2 < 0 )
-	{
-		/* take the inverse of the source if negative power */
-		/* a work array is needed, but that was included in the
-		   demand of this function */
-		offset = workMatrix.columns * workMatrix.rows;
-
-		/* the first part of the work array is the destination
-		   the last part is work memory of the inverse */
-		XXMatrixInverse(&workMatrix, mat_dest, &workarray[offset]);
-
-		/* and copy the workmatrix to the destination */
-		XXMatrixMov(mat_dest, &workMatrix);
-	}
+void XXMatrixPow(
+  XXMatrix *mat_dest, XXMatrix *mat_source1,
+  XXDouble s2, XXDouble *workarray)
+{
+  XXDouble abssrc2;
+  XXInteger i, pow_val, offset;
+  XXMatrix workMatrix;
+
+  abssrc2 = (XXDouble) fabs(s2);
+  pow_val = (XXInteger)(abssrc2 + 0.1);
+
+        /* map the work array on a local matrix */
+  workMatrix.columns = mat_dest->columns;
+  workMatrix.rows = mat_dest->rows;
+  workMatrix.mat = workarray;
+
+        /* first set the matrix to the eye value. */
+  XXMatrixEye(mat_dest);
+
+        /* keep multiplying the matrix with the source. */
+  for( i = 0; i < pow_val; i++ ) {
+                /* multiply the source with the destination to the work matrix */
+    XXMatrixMul(&workMatrix, mat_dest, mat_source1);
+
+                /* and copy the workmatrix to the destination */
+    XXMatrixMov(mat_dest, &workMatrix);
+  }
+
+  if(s2 < 0) {
+                /* take the inverse of the source if negative power */
+                /* a work array is needed, but that was included in the
+                   demand of this function */
+    offset = workMatrix.columns * workMatrix.rows;
+
+                /* the first part of the work array is the destination
+                   the last part is work memory of the inverse */
+    XXMatrixInverse(&workMatrix, mat_dest, &workarray[offset]);
+
+                /* and copy the workmatrix to the destination */
+    XXMatrixMov(mat_dest, &workMatrix);
+  }
@@ -728,12 +697,11 @@
-void XXScalarScalarPow (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
-{
-	XXDouble value;
-	XXInteger i;
-	const XXInteger size = mat_dest->rows * mat_dest->columns;
-
-	value = (XXDouble) pow(s1, s2);
-	
-	for(i = 0; i < size; i++)
-	{
-		mat_dest->mat[i] = value;
-	}
+void XXScalarScalarPow(XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
+{
+  XXDouble value;
+  XXInteger i;
+  const XXInteger size = mat_dest->rows * mat_dest->columns;
+
+  value = (XXDouble) pow(s1, s2);
+
+  for(i = 0; i < size; i++) {
+    mat_dest->mat[i] = value;
+  }
@@ -745,12 +713,12 @@
-void XXMatrixCrossProduct (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXDouble *d, *s1, *s2;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	/* just do it */
-	d[0] = s1[1] * s2[2] - s1[2] * s2[1];
-	d[1] = s1[2] * s2[0] - s1[0] * s2[2];
-	d[2] = s1[0] * s2[1] - s1[1] * s2[0];
+void XXMatrixCrossProduct(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXDouble *d, *s1, *s2;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+        /* just do it */
+  d[0] = s1[1] * s2[2] - s1[2] * s2[1];
+  d[1] = s1[2] * s2[0] - s1[0] * s2[2];
+  d[2] = s1[0] * s2[1] - s1[1] * s2[0];
@@ -762,16 +730,15 @@
-void XXMatrixInnerProduct (XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXInteger i;
-	XXDouble *s1, *s2;
-
-	i = mat_source1->rows;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	*dest = 0.0;
-	while(i)
-	{
-		*dest += (*s1) * (*s2);
-		s1++;s2++;
-		i--;
-	}
+void XXMatrixInnerProduct(XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXInteger i;
+  XXDouble *s1, *s2;
+
+  i = mat_source1->rows;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+  *dest = 0.0;
+  while(i) {
+    *dest += (*s1) * (*s2);
+    s1++;s2++;
+    i--;
+  }
@@ -782,20 +749,19 @@
-void XXMatrixNorm (XXDouble *dest, XXMatrix *mat_source)
-{
-	/* the implementation as on page 195 of Numerical Methods. */
-	XXDouble *s;
-	XXInteger i;
-	XXDouble t;
-
-	s = mat_source->mat;
-	i = mat_source->rows * mat_source->columns;
-	t = 0.0;
-
-	while(i)
-	{
-		t += (*s) * (*s);
-		s++;
-		i--;
-	}
-
-	/* and take the square root of the result */
-	*dest = sqrt(t);
+void XXMatrixNorm(XXDouble *dest, XXMatrix *mat_source)
+{
+        /* the implementation as on page 195 of Numerical Methods. */
+  XXDouble *s;
+  XXInteger i;
+  XXDouble t;
+
+  s = mat_source->mat;
+  i = mat_source->rows * mat_source->columns;
+  t = 0.0;
+
+  while(i) {
+    t += (*s) * (*s);
+    s++;
+    i--;
+  }
+
+        /* and take the square root of the result */
+  *dest = sqrt(t);
@@ -806,24 +772,21 @@
-void XXMatrixNormInf (XXDouble *dest, XXMatrix *mat_source)
-{
-	/* the implementation as on page 195/196 of Numerical Methods. */
-	XXDouble p;
-	XXDouble *s;
-	XXInteger i, j, rows, columns;
-
-	s = mat_source->mat;
-	rows = mat_source->rows;
-	columns = mat_source->columns;
-
-	*dest = 0.0;
-	for( i = 0; i < rows; i++ )
-	{
-		p = 0.0;
-		for( j = 0; j < columns; j++ )
-		{
-			p += fabs(s[i*columns+j]);
-		}
-		if( p > (*dest) )
-		{
-			*dest = p;
-		}
-	}
+void XXMatrixNormInf(XXDouble *dest, XXMatrix *mat_source)
+{
+        /* the implementation as on page 195/196 of Numerical Methods. */
+  XXDouble p;
+  XXDouble *s;
+  XXInteger i, j, rows, columns;
+
+  s = mat_source->mat;
+  rows = mat_source->rows;
+  columns = mat_source->columns;
+
+  *dest = 0.0;
+  for( i = 0; i < rows; i++ ) {
+    p = 0.0;
+    for( j = 0; j < columns; j++ ) {
+      p += fabs(s[i * columns + j]);
+    }
+    if(p > (*dest) ) {
+      *dest = p;
+    }
+  }
@@ -833,10 +796,10 @@
-void XXMatrixSinCos (XXMatrix *mat_dest, XXDouble argument)
-{
-	XXDouble s, c;
-
-	/* this is optimized depending on the compiler */
-	s = sin (argument);
-	c = cos (argument);
-
-	mat_dest->mat[0] = s;
-	mat_dest->mat[1] = c;
+void XXMatrixSinCos(XXMatrix *mat_dest, XXDouble argument)
+{
+  XXDouble s, c;
+
+        /* this is optimized depending on the compiler */
+  s = sin (argument);
+  c = cos (argument);
+
+  mat_dest->mat[0] = s;
+  mat_dest->mat[1] = c;
@@ -848,18 +811,17 @@
-XXDouble XXMatrixTrace (XXMatrix *mat_source)
-{
-	XXDouble *s;
-	XXDouble dest;
-	XXInteger i;
-	const XXInteger rows = mat_source->rows;
-	const XXInteger columns = mat_source->columns;
-
-	s = mat_source->mat;
-	i = 0;
-
-	dest = 0.0;
-	while( i < rows && i < columns )
-	{
-		dest += s[i*(columns+1)];
-		i++;
-	}
-	return dest;
+XXDouble XXMatrixTrace(XXMatrix *mat_source)
+{
+  XXDouble *s;
+  XXDouble dest;
+  XXInteger i;
+  const XXInteger rows = mat_source->rows;
+  const XXInteger columns = mat_source->columns;
+
+  s = mat_source->mat;
+  i = 0;
+
+  dest = 0.0;
+  while(i < rows && i < columns) {
+    dest += s[i * (columns + 1)];
+    i++;
+  }
+  return dest;
@@ -872,18 +834,18 @@
-void XXMatrixSym (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
-{
-	/* and a work matrix */
-	XXMatrix workMatrix;
-
-	/* map the work array on a local matrix */
-	workMatrix.columns = mat_dest->columns;
-	workMatrix.rows = mat_dest->rows;
-	workMatrix.mat = workarray;
-
-	/* first transpose the source to the destination */
-	XXMatrixTranspose(mat_dest, mat_source);
-
-	/* add those two matrices to the work array */
-	XXMatrixAdd(&workMatrix, mat_dest, mat_source);
-
-	/* and divide by a scalar two */
-	XXMatrixScalarDiv(mat_dest, &workMatrix, 2.0);
+void XXMatrixSym(XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
+{
+        /* and a work matrix */
+  XXMatrix workMatrix;
+
+        /* map the work array on a local matrix */
+  workMatrix.columns = mat_dest->columns;
+  workMatrix.rows = mat_dest->rows;
+  workMatrix.mat = workarray;
+
+        /* first transpose the source to the destination */
+  XXMatrixTranspose(mat_dest, mat_source);
+
+        /* add those two matrices to the work array */
+  XXMatrixAdd(&workMatrix, mat_dest, mat_source);
+
+        /* and divide by a scalar two */
+  XXMatrixScalarDiv(mat_dest, &workMatrix, 2.0);
@@ -896,18 +858,18 @@
-void XXMatrixAsym (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
-{
-	/* and a work matrix */
-	XXMatrix workMatrix;
-
-	/* map the work array on a local matrix */
-	workMatrix.columns = mat_dest->columns;
-	workMatrix.rows = mat_dest->rows;
-	workMatrix.mat = workarray;
-
-	/* first transpose the source to the destination */
-	XXMatrixTranspose(mat_dest, mat_source);
-
-	/* subtract those two matrices to the work array */
-	XXMatrixSub(&workMatrix, mat_source, mat_dest);
-
-	/* and divide by a scalar two */
-	XXMatrixScalarDiv(mat_dest, &workMatrix, 2.0);
+void XXMatrixAsym(XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
+{
+        /* and a work matrix */
+  XXMatrix workMatrix;
+
+        /* map the work array on a local matrix */
+  workMatrix.columns = mat_dest->columns;
+  workMatrix.rows = mat_dest->rows;
+  workMatrix.mat = workarray;
+
+        /* first transpose the source to the destination */
+  XXMatrixTranspose(mat_dest, mat_source);
+
+        /* subtract those two matrices to the work array */
+  XXMatrixSub(&workMatrix, mat_source, mat_dest);
+
+        /* and divide by a scalar two */
+  XXMatrixScalarDiv(mat_dest, &workMatrix, 2.0);
@@ -919,21 +881,21 @@
-void XXMatrixSkew (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	XXDouble *d, *s;
-
-	d = mat_dest->mat;
-	s = mat_source->mat;
-
-	/* row one */
-	d[0] = 0.0;
-	d[1] = -s[2];
-	d[2] =  s[1];
-
-	/* row two */
-	d[3] =  s[2];
-	d[4] = 0.0;
-	d[5] = -s[0];
-
-	/* row three */
-	d[6] = -s[1];
-	d[7] =  s[0];
-	d[8] = 0.0;
+void XXMatrixSkew(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  XXDouble *d, *s;
+
+  d = mat_dest->mat;
+  s = mat_source->mat;
+
+        /* row one */
+  d[0] = 0.0;
+  d[1] = -s[2];
+  d[2] = s[1];
+
+        /* row two */
+  d[3] = s[2];
+  d[4] = 0.0;
+  d[5] = -s[0];
+
+        /* row three */
+  d[6] = -s[1];
+  d[7] = s[0];
+  d[8] = 0.0;
@@ -946,31 +908,31 @@
-void XXMatrixHomogeneous (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXDouble *d, *s1, *s2;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	/* row one */
-	d[0] = s1[0];
-	d[1] = s1[1];
-	d[2] = s1[2];
-	d[3] = s2[0];
-
-	/* row two */
-	d[4] = s1[3];
-	d[5] = s1[4];
-	d[6] = s1[5];
-	d[7] = s2[1];
-
-	/* row three */
-	d[8] = s1[6];
-	d[9] = s1[7];
-	d[10] = s1[8];
-	d[11] = s2[2];
-
-	/* row four */
-	d[12] = 0.0;
-	d[13] = 0.0;
-	d[14] = 0.0;
-	d[15] = 1.0;
+void XXMatrixHomogeneous(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXDouble *d, *s1, *s2;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+        /* row one */
+  d[0] = s1[0];
+  d[1] = s1[1];
+  d[2] = s1[2];
+  d[3] = s2[0];
+
+        /* row two */
+  d[4] = s1[3];
+  d[5] = s1[4];
+  d[6] = s1[5];
+  d[7] = s2[1];
+
+        /* row three */
+  d[8] = s1[6];
+  d[9] = s1[7];
+  d[10] = s1[8];
+  d[11] = s2[2];
+
+        /* row four */
+  d[12] = 0.0;
+  d[13] = 0.0;
+  d[14] = 0.0;
+  d[15] = 1.0;
@@ -982,32 +944,32 @@
-void XXMatrixInverseH (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	XXDouble *d, *s;
-
-	d = mat_dest->mat;
-	s = mat_source->mat;
-
-	/* row one */
-	d[0] = s[0];
-	d[1] = s[4];
-	d[2] = s[8];
-
-	/* row two */
-	d[4] = s[1];
-	d[5] = s[5];
-	d[6] = s[9];
-
-	/* row three */
-	d[8] = s[2];
-	d[9] = s[6];
-	d[10] = s[10];
-
-	/* and the position */
-	d[3] = -(d[0] * s[3] + d[1] * s[7] + d[2] * s[11] );
-	d[7] = -(d[4] * s[3] + d[5] * s[7] + d[6] * s[11] );
-	d[11] = -(d[8] * s[3] + d[9] * s[7] + d[10] * s[11] );
-
-	/* row four */
-	d[12] = 0.0;
-	d[13] = 0.0;
-	d[14] = 0.0;
-	d[15] = 1.0;
+void XXMatrixInverseH(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  XXDouble *d, *s;
+
+  d = mat_dest->mat;
+  s = mat_source->mat;
+
+        /* row one */
+  d[0] = s[0];
+  d[1] = s[4];
+  d[2] = s[8];
+
+        /* row two */
+  d[4] = s[1];
+  d[5] = s[5];
+  d[6] = s[9];
+
+        /* row three */
+  d[8] = s[2];
+  d[9] = s[6];
+  d[10] = s[10];
+
+        /* and the position */
+  d[3] = -(d[0] * s[3] + d[1] * s[7] + d[2] * s[11] );
+  d[7] = -(d[4] * s[3] + d[5] * s[7] + d[6] * s[11] );
+  d[11] = -(d[8] * s[3] + d[9] * s[7] + d[10] * s[11] );
+
+        /* row four */
+  d[12] = 0.0;
+  d[13] = 0.0;
+  d[14] = 0.0;
+  d[15] = 1.0;
@@ -1019,54 +981,54 @@
-void XXMatrixAdjoint (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	XXDouble *d, *s;
-
-	d = mat_dest->mat;
-	s = mat_source->mat;
-
-	/* row one */
-	d[0] = s[0];
-	d[1] = s[1];
-	d[2] = s[2];
-	d[3] = 0.0;
-	d[4] = 0.0;
-	d[5] = 0.0;
-
-	/* row two */
-	d[6] = s[4];
-	d[7] = s[5];
-	d[8] = s[6];
-	d[9] = 0.0;
-	d[10] = 0.0;
-	d[11] = 0.0;
-
-	/* row three */
-	d[12] = s[8];
-	d[13] = s[9];
-	d[14] = s[10];
-	d[15] = 0.0;
-	d[16] = 0.0;
-	d[17] = 0.0;
-
-	/* row four */
-	d[18] = -s[11] * s[4] + s[7] * s[8];
-	d[19] = -s[11] * s[5] + s[7] * s[9];
-	d[20] = -s[11] * s[6] + s[7] * s[10];
-	d[21] = s[0];
-	d[22] = s[1];
-	d[23] = s[2];
-
-	/* row five */
-	d[24] = s[11] * s[0] - s[3] * s[8];
-	d[25] = s[11] * s[1] - s[3] * s[9];
-	d[26] = s[11] * s[2] - s[3] * s[10];
-	d[27] = s[4];
-	d[28] = s[5];
-	d[29] = s[6];
-
-	/* row six */
-	d[30] = -s[7] * s[0] + s[3] * s[4];
-	d[31] = -s[7] * s[1] + s[3] * s[5];
-	d[32] = -s[7] * s[2] + s[3] * s[6];
-	d[33] = s[8];
-	d[34] = s[9];
-	d[35] = s[10];
+void XXMatrixAdjoint(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  XXDouble *d, *s;
+
+  d = mat_dest->mat;
+  s = mat_source->mat;
+
+        /* row one */
+  d[0] = s[0];
+  d[1] = s[1];
+  d[2] = s[2];
+  d[3] = 0.0;
+  d[4] = 0.0;
+  d[5] = 0.0;
+
+        /* row two */
+  d[6] = s[4];
+  d[7] = s[5];
+  d[8] = s[6];
+  d[9] = 0.0;
+  d[10] = 0.0;
+  d[11] = 0.0;
+
+        /* row three */
+  d[12] = s[8];
+  d[13] = s[9];
+  d[14] = s[10];
+  d[15] = 0.0;
+  d[16] = 0.0;
+  d[17] = 0.0;
+
+        /* row four */
+  d[18] = -s[11] * s[4] + s[7] * s[8];
+  d[19] = -s[11] * s[5] + s[7] * s[9];
+  d[20] = -s[11] * s[6] + s[7] * s[10];
+  d[21] = s[0];
+  d[22] = s[1];
+  d[23] = s[2];
+
+        /* row five */
+  d[24] = s[11] * s[0] - s[3] * s[8];
+  d[25] = s[11] * s[1] - s[3] * s[9];
+  d[26] = s[11] * s[2] - s[3] * s[10];
+  d[27] = s[4];
+  d[28] = s[5];
+  d[29] = s[6];
+
+        /* row six */
+  d[30] = -s[7] * s[0] + s[3] * s[4];
+  d[31] = -s[7] * s[1] + s[3] * s[5];
+  d[32] = -s[7] * s[2] + s[3] * s[6];
+  d[33] = s[8];
+  d[34] = s[9];
+  d[35] = s[10];
@@ -1081,55 +1043,55 @@
-void XXMatrixAdjoint1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXDouble *d, *s1, *s2;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	/* row one */
-	d[0] = s1[0];
-	d[1] = s1[1];
-	d[2] = s1[2];
-	d[3] = 0.0;
-	d[4] = 0.0;
-	d[5] = 0.0;
-
-	/* row two */
-	d[6] = s1[3];
-	d[7] = s1[4];
-	d[8] = s1[5];
-	d[9] = 0.0;
-	d[10] = 0.0;
-	d[11] = 0.0;
-
-	/* row three */
-	d[12] = s1[6];
-	d[13] = s1[7];
-	d[14] = s1[8];
-	d[15] = 0.0;
-	d[16] = 0.0;
-	d[17] = 0.0;
-
-	/* row four */
-	d[18] = -s2[2] * s1[3] + s2[1] * s1[6];
-	d[19] = -s2[2] * s1[4] + s2[1] * s1[7];
-	d[20] = -s2[2] * s1[5] + s2[1] * s1[8];
-	d[21] = s1[0];
-	d[22] = s1[1];
-	d[23] = s1[2];
-
-	/* row five */
-	d[24] = s2[2] * s1[0] - s2[0] * s1[6];
-	d[25] = s2[2] * s1[1] - s2[0] * s1[7];
-	d[26] = s2[2] * s1[2] - s2[0] * s1[8];
-	d[27] = s1[3];
-	d[28] = s1[4];
-	d[29] = s1[5];
-
-	/* row six */
-	d[30] = -s2[1] * s1[0] + s2[0] * s1[3];
-	d[31] = -s2[1] * s1[1] + s2[0] * s1[4];
-	d[32] = -s2[1] * s1[2] + s2[0] * s1[5];
-	d[33] = s1[6];
-	d[34] = s1[7];
-	d[35] = s1[8];
+void XXMatrixAdjoint1(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXDouble *d, *s1, *s2;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+        /* row one */
+  d[0] = s1[0];
+  d[1] = s1[1];
+  d[2] = s1[2];
+  d[3] = 0.0;
+  d[4] = 0.0;
+  d[5] = 0.0;
+
+        /* row two */
+  d[6] = s1[3];
+  d[7] = s1[4];
+  d[8] = s1[5];
+  d[9] = 0.0;
+  d[10] = 0.0;
+  d[11] = 0.0;
+
+        /* row three */
+  d[12] = s1[6];
+  d[13] = s1[7];
+  d[14] = s1[8];
+  d[15] = 0.0;
+  d[16] = 0.0;
+  d[17] = 0.0;
+
+        /* row four */
+  d[18] = -s2[2] * s1[3] + s2[1] * s1[6];
+  d[19] = -s2[2] * s1[4] + s2[1] * s1[7];
+  d[20] = -s2[2] * s1[5] + s2[1] * s1[8];
+  d[21] = s1[0];
+  d[22] = s1[1];
+  d[23] = s1[2];
+
+        /* row five */
+  d[24] = s2[2] * s1[0] - s2[0] * s1[6];
+  d[25] = s2[2] * s1[1] - s2[0] * s1[7];
+  d[26] = s2[2] * s1[2] - s2[0] * s1[8];
+  d[27] = s1[3];
+  d[28] = s1[4];
+  d[29] = s1[5];
+
+        /* row six */
+  d[30] = -s2[1] * s1[0] + s2[0] * s1[3];
+  d[31] = -s2[1] * s1[1] + s2[0] * s1[4];
+  d[32] = -s2[1] * s1[2] + s2[0] * s1[5];
+  d[33] = s1[6];
+  d[34] = s1[7];
+  d[35] = s1[8];
@@ -1143,54 +1105,54 @@
-void XXMatrixadjoint (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	XXDouble *d, *s;
-
-	d = mat_dest->mat;
-	s = mat_source->mat;
-
-	/* row one */
-	d[0] = 0.0;
-	d[1] = -s[2];
-	d[2] =  s[1];
-	d[3] = 0.0;
-	d[4] = 0.0;
-	d[5] = 0.0;
-
-	/* row two */
-	d[6] =  s[2];
-	d[7] = 0.0;
-	d[8] = -s[0];
-	d[9] = 0.0;
-	d[10] = 0.0;
-	d[11] = 0.0;
-
-	/* row three */
-	d[12] = -s[1];
-	d[13] =  s[0];
-	d[14] = 0.0;
-	d[15] = 0.0;
-	d[16] = 0.0;
-	d[17] = 0.0;
-
-	/* row four */
-	d[18] = 0;
-	d[19] = -s[5];
-	d[20] =  s[4];
-	d[21] = 0.0;
-	d[22] = -s[2];
-	d[23] =  s[1];
-
-	/* row two */
-	d[24] =  s[5];
-	d[25] = 0.0;
-	d[26] = -s[3];
-	d[27] =  s[2];
-	d[28] = 0.0;
-	d[29] = -s[0];
-
-	/* row three */
-	d[30] = -s[4];
-	d[31] =  s[3];
-	d[32] = 0.0;
-	d[33] = -s[1];
-	d[34] =  s[0];
-	d[35] = 0.0;
+void XXMatrixadjoint(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  XXDouble *d, *s;
+
+  d = mat_dest->mat;
+  s = mat_source->mat;
+
+        /* row one */
+  d[0] = 0.0;
+  d[1] = -s[2];
+  d[2] = s[1];
+  d[3] = 0.0;
+  d[4] = 0.0;
+  d[5] = 0.0;
+
+        /* row two */
+  d[6] = s[2];
+  d[7] = 0.0;
+  d[8] = -s[0];
+  d[9] = 0.0;
+  d[10] = 0.0;
+  d[11] = 0.0;
+
+        /* row three */
+  d[12] = -s[1];
+  d[13] = s[0];
+  d[14] = 0.0;
+  d[15] = 0.0;
+  d[16] = 0.0;
+  d[17] = 0.0;
+
+        /* row four */
+  d[18] = 0;
+  d[19] = -s[5];
+  d[20] = s[4];
+  d[21] = 0.0;
+  d[22] = -s[2];
+  d[23] = s[1];
+
+        /* row two */
+  d[24] = s[5];
+  d[25] = 0.0;
+  d[26] = -s[3];
+  d[27] = s[2];
+  d[28] = 0.0;
+  d[29] = -s[0];
+
+        /* row three */
+  d[30] = -s[4];
+  d[31] = s[3];
+  d[32] = 0.0;
+  d[33] = -s[1];
+  d[34] = s[0];
+  d[35] = 0.0;
@@ -1205,55 +1167,55 @@
-void XXMatrixadjoint1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXDouble *d, *s1, *s2;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	/* row one */
-	d[0] = 0.0;
-	d[1] = -s1[2];
-	d[2] =  s1[1];
-	d[3] = 0.0;
-	d[4] = 0.0;
-	d[5] = 0.0;
-
-	/* row two */
-	d[6] =  s1[2];
-	d[7] = 0.0;
-	d[8] = -s1[0];
-	d[9] = 0.0;
-	d[10] = 0.0;
-	d[11] = 0.0;
-
-	/* row three */
-	d[12] = -s1[1];
-	d[13] =  s1[0];
-	d[14] = 0.0;
-	d[15] = 0.0;
-	d[16] = 0.0;
-	d[17] = 0.0;
-
-	/* row four */
-	d[18] = 0.0;
-	d[19] = -s2[2];
-	d[20] =  s2[1];
-	d[21] = 0.0;
-	d[22] = -s1[2];
-	d[23] =  s1[1];
-
-	/* row two */
-	d[24] =  s2[2];
-	d[25] = 0.0;
-	d[26] = -s2[0];
-	d[27] =  s1[2];
-	d[28] = 0.0;
-	d[29] = -s1[0];
-
-	/* row three */
-	d[30] = -s2[1];
-	d[31] =  s2[0];
-	d[32] = 0.0;
-	d[33] = -s1[1];
-	d[34] =  s1[0];
-	d[35] = 0.0;
+void XXMatrixadjoint1(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXDouble *d, *s1, *s2;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+        /* row one */
+  d[0] = 0.0;
+  d[1] = -s1[2];
+  d[2] = s1[1];
+  d[3] = 0.0;
+  d[4] = 0.0;
+  d[5] = 0.0;
+
+        /* row two */
+  d[6] = s1[2];
+  d[7] = 0.0;
+  d[8] = -s1[0];
+  d[9] = 0.0;
+  d[10] = 0.0;
+  d[11] = 0.0;
+
+        /* row three */
+  d[12] = -s1[1];
+  d[13] = s1[0];
+  d[14] = 0.0;
+  d[15] = 0.0;
+  d[16] = 0.0;
+  d[17] = 0.0;
+
+        /* row four */
+  d[18] = 0.0;
+  d[19] = -s2[2];
+  d[20] = s2[1];
+  d[21] = 0.0;
+  d[22] = -s1[2];
+  d[23] = s1[1];
+
+        /* row two */
+  d[24] = s2[2];
+  d[25] = 0.0;
+  d[26] = -s2[0];
+  d[27] = s1[2];
+  d[28] = 0.0;
+  d[29] = -s1[0];
+
+        /* row three */
+  d[30] = -s2[1];
+  d[31] = s2[0];
+  d[32] = 0.0;
+  d[33] = -s1[1];
+  d[34] = s1[0];
+  d[35] = 0.0;
@@ -1266,30 +1228,30 @@
-void XXMatrixTilde (XXMatrix *mat_dest, XXMatrix *mat_source)
-{
-	XXDouble *d, *s;
-
-	d = mat_dest->mat;
-	s = mat_source->mat;
-
-	/* row one */
-	d[0] = 0.0;
-	d[1] = -s[2];
-	d[2] =  s[1];
-	d[3] =  s[3];
-
-	/* row two */
-	d[4] =  s[2];
-	d[5] = 0.0;
-	d[6] = -s[0];
-	d[7] =  s[4];
-
-	/* row three */
-	d[8] = -s[1];
-	d[9] =  s[0];
-	d[10] = 0.0;
-	d[11] = s[5];
-
-	/* row four */
-	d[12] = 0.0;
-	d[13] = 0.0;
-	d[14] = 0.0;
-	d[15] = 0.0;
+void XXMatrixTilde(XXMatrix *mat_dest, XXMatrix *mat_source)
+{
+  XXDouble *d, *s;
+
+  d = mat_dest->mat;
+  s = mat_source->mat;
+
+        /* row one */
+  d[0] = 0.0;
+  d[1] = -s[2];
+  d[2] = s[1];
+  d[3] = s[3];
+
+        /* row two */
+  d[4] = s[2];
+  d[5] = 0.0;
+  d[6] = -s[0];
+  d[7] = s[4];
+
+        /* row three */
+  d[8] = -s[1];
+  d[9] = s[0];
+  d[10] = 0.0;
+  d[11] = s[5];
+
+        /* row four */
+  d[12] = 0.0;
+  d[13] = 0.0;
+  d[14] = 0.0;
+  d[15] = 0.0;
@@ -1304,34 +1266,34 @@
-void XXMatrixTilde1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
-{
-	XXDouble *d, *s1, *s2;
-
-	d = mat_dest->mat;
-	s1 = mat_source1->mat;
-	s2 = mat_source2->mat;
-
-	/* row one */
-	d[0] = 0.0;
-	d[1] = -s1[2];
-	d[2] =  s1[1];
-	d[3] =  s2[0];
-
-	/* row two */
-	d[4] =  s1[2];
-	d[5] = 0.0;
-	d[6] = -s1[0];
-	d[7] =  s2[1];
-
-	/* row three */
-	d[8] = -s1[1];
-	d[9] =  s1[0];
-	d[10] = 0.0;
-	d[11] = s2[2];
-
-	/* row four */
-	d[12] = 0.0;
-	d[13] = 0.0;
-	d[14] = 0.0;
-	d[15] = 0.0;
-}
-
-/* calculate the solution of A x = b towards x 
+void XXMatrixTilde1(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
+{
+  XXDouble *d, *s1, *s2;
+
+  d = mat_dest->mat;
+  s1 = mat_source1->mat;
+  s2 = mat_source2->mat;
+
+        /* row one */
+  d[0] = 0.0;
+  d[1] = -s1[2];
+  d[2] = s1[1];
+  d[3] = s2[0];
+
+        /* row two */
+  d[4] = s1[2];
+  d[5] = 0.0;
+  d[6] = -s1[0];
+  d[7] = s2[1];
+
+        /* row three */
+  d[8] = -s1[1];
+  d[9] = s1[0];
+  d[10] = 0.0;
+  d[11] = s2[2];
+
+        /* row four */
+  d[12] = 0.0;
+  d[13] = 0.0;
+  d[14] = 0.0;
+  d[15] = 0.0;
+}
+
+/* calculate the solution of A x = b towards x
@@ -1340,17 +1302,18 @@
-void XXLinearSolve (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2, XXString method, XXInteger id, XXDouble *workarray)
-{
-	/* a work matrix */
-	XXMatrix workMatrix;
-
-	/* map the work array on a local matrix */
-	workMatrix.columns = mat_source1->columns;
-	workMatrix.rows = mat_source1->rows;
-	workMatrix.mat = workarray;
-
-	/* calculate the inverse */
-	XXMatrixInverse (&workMatrix, mat_source1, workarray + (workMatrix.columns * workMatrix.rows));
-	
-	/* and multiply with b */
-	XXMatrixMul (mat_dest, &workMatrix, mat_source2);
-}
-
+void XXLinearSolve(
+  XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2,
+  XXString method, XXInteger id, XXDouble *workarray)
+{
+        /* a work matrix */
+  XXMatrix workMatrix;
+
+        /* map the work array on a local matrix */
+  workMatrix.columns = mat_source1->columns;
+  workMatrix.rows = mat_source1->rows;
+  workMatrix.mat = workarray;
+
+        /* calculate the inverse */
+  XXMatrixInverse (&workMatrix, mat_source1, workarray + (workMatrix.columns * workMatrix.rows));
+
+        /* and multiply with b */
+  XXMatrixMul (mat_dest, &workMatrix, mat_source2);
+}
]]></failure>
  </testcase>
  <testcase
    name="common/xxmatrix.h"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 188 lines"><![CDATA[--- common/xxmatrix.h
+++ common/xxmatrix.h.uncrustify
@@ -22 +22 @@
-void XXMatrixMov (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixMov(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -25 +25 @@
-void XXMatrixScalarMov (XXMatrix *mat_dest, XXDouble s);
+void XXMatrixScalarMov(XXMatrix *mat_dest, XXDouble s);
@@ -29 +29 @@
-void XXMatrixGetRow (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row);
+void XXMatrixGetRow(XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row);
@@ -33 +33 @@
-void XXMatrixSetRow (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row);
+void XXMatrixSetRow(XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row);
@@ -37 +37 @@
-void XXMatrixGetColumn (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column);
+void XXMatrixGetColumn(XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column);
@@ -41 +41 @@
-void XXMatrixSetColumn (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column);
+void XXMatrixSetColumn(XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column);
@@ -45 +45 @@
-void XXMatrixDiag (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixDiag(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -48 +48 @@
-void XXMatrixAdd (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixAdd(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -51 +51 @@
-void XXMatrixScalarAdd (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2);
+void XXMatrixScalarAdd(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2);
@@ -54 +54 @@
-void XXScalarMatrixAdd (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2);
+void XXScalarMatrixAdd(XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2);
@@ -57 +57 @@
-void XXScalarScalarAdd (XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
+void XXScalarScalarAdd(XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
@@ -60 +60 @@
-void XXMatrixSub (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixSub(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -63 +63 @@
-void XXMatrixScalarSub (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2);
+void XXMatrixScalarSub(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2);
@@ -66 +66 @@
-void XXScalarMatrixSub (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2);
+void XXScalarMatrixSub(XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2);
@@ -69 +69 @@
-void XXScalarScalarSub (XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
+void XXScalarScalarSub(XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
@@ -72 +72 @@
-void XXMatrixMul (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixMul(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -75 +75 @@
-void XXMatrixScalarMul (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2);
+void XXMatrixScalarMul(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2);
@@ -78 +78 @@
-void XXScalarMatrixMul (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2);
+void XXScalarMatrixMul(XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2);
@@ -85 +85 @@
-void XXScalarMatrixMatrixMul (XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXScalarMatrixMatrixMul(XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -88 +88 @@
-void XXMatrixMulElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixMulElement(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -91 +91 @@
-void XXMatrixDivElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixDivElement(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -94 +94 @@
-void XXMatrixScalarPowElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble scalar_source2);
+void XXMatrixScalarPowElement(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble scalar_source2);
@@ -96 +96 @@
-void XXMatrixPowElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixPowElement(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -101 +101 @@
-void XXMatrixInverse (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray);
+void XXMatrixInverse(XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray);
@@ -106 +106,3 @@
-void XXMatrixDiv (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2, XXDouble *workarray);
+void XXMatrixDiv(
+  XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2,
+  XXDouble *workarray);
@@ -109 +111 @@
-void XXMatrixScalarDiv (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2);
+void XXMatrixScalarDiv(XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2);
@@ -114 +116 @@
-void XXScalarMatrixDiv (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2, XXDouble *workarray);
+void XXScalarMatrixDiv(XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2, XXDouble *workarray);
@@ -117 +119 @@
-void XXScalarScalarDiv (XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
+void XXScalarScalarDiv(XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
@@ -120 +122 @@
-void XXMatrixInv (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixInv(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -123 +125 @@
-void XXMatrixTranspose (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixTranspose(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -126 +128 @@
-XXDouble XXMatrixDeterminant (XXMatrix *mat_source, XXDouble *workarray);
+XXDouble XXMatrixDeterminant(XXMatrix *mat_source, XXDouble *workarray);
@@ -130 +132 @@
-void XXMatrixMovRelAbs (XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
+void XXMatrixMovRelAbs(XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
@@ -134 +136 @@
-void XXMatrixMovAbsRel (XXDouble *dest, XXMatrix *mat_source1, XXDouble s2);
+void XXMatrixMovAbsRel(XXDouble *dest, XXMatrix *mat_source1, XXDouble s2);
@@ -138 +140 @@
-void XXMatrixMinimum (XXDouble *dest, XXMatrix *mat_source);
+void XXMatrixMinimum(XXDouble *dest, XXMatrix *mat_source);
@@ -142 +144 @@
-void XXMatrixMaximum (XXDouble *dest, XXMatrix *mat_source);
+void XXMatrixMaximum(XXDouble *dest, XXMatrix *mat_source);
@@ -145 +147 @@
-void XXMatrixSum (XXDouble *dest, XXMatrix *mat_source);
+void XXMatrixSum(XXDouble *dest, XXMatrix *mat_source);
@@ -148 +150 @@
-void XXMatrixEye (XXMatrix *mat_dest);
+void XXMatrixEye(XXMatrix *mat_dest);
@@ -156,2 +158,3 @@
-void XXMatrixPow (XXMatrix *mat_dest, XXMatrix *mat_source1,
-				XXDouble s2, XXDouble *workarray);
+void XXMatrixPow(
+  XXMatrix *mat_dest, XXMatrix *mat_source1,
+  XXDouble s2, XXDouble *workarray);
@@ -159 +162 @@
-void XXScalarScalarPow (XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
+void XXScalarScalarPow(XXMatrix *mat_dest, XXDouble s1, XXDouble s2);
@@ -163 +166 @@
-void XXMatrixCrossProduct (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixCrossProduct(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -167 +170 @@
-void XXMatrixInnerProduct (XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixInnerProduct(XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -170 +173 @@
-void XXMatrixNorm (XXDouble *dest, XXMatrix *mat_source);
+void XXMatrixNorm(XXDouble *dest, XXMatrix *mat_source);
@@ -173 +176 @@
-void XXMatrixNormInf (XXDouble *dest, XXMatrix *mat_source);
+void XXMatrixNormInf(XXDouble *dest, XXMatrix *mat_source);
@@ -177 +180 @@
-XXDouble XXMatrixTrace (XXMatrix *mat_source);
+XXDouble XXMatrixTrace(XXMatrix *mat_source);
@@ -179 +182 @@
-void XXMatrixSinCos (XXMatrix *mat_dest, XXDouble argument);
+void XXMatrixSinCos(XXMatrix *mat_dest, XXDouble argument);
@@ -183 +186 @@
-void XXMatrixSym (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray);
+void XXMatrixSym(XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray);
@@ -188 +191 @@
-void XXMatrixAsym (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray);
+void XXMatrixAsym(XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray);
@@ -192 +195 @@
-void XXMatrixSkew (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixSkew(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -197 +200 @@
-void XXMatrixHomogeneous (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixHomogeneous(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -201 +204 @@
-void XXMatrixInverseH (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixInverseH(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -205 +208 @@
-void XXMatrixAdjoint (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixAdjoint(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -211 +214 @@
-void XXMatrixAdjoint1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixAdjoint1(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -216 +219 @@
-void XXMatrixadjoint (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixadjoint(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -222 +225 @@
-void XXMatrixadjoint1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+void XXMatrixadjoint1(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
@@ -227 +230 @@
-void XXMatrixTilde (XXMatrix *mat_dest, XXMatrix *mat_source);
+void XXMatrixTilde(XXMatrix *mat_dest, XXMatrix *mat_source);
@@ -233,3 +236,3 @@
-void XXMatrixTilde1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
-
-/* calculate the solution of Ax=b towards x 
+void XXMatrixTilde1(XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2);
+
+/* calculate the solution of Ax=b towards x
@@ -238 +241,3 @@
-void XXLinearSolve (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2, XXString method, XXInteger id, XXDouble *workarray);
+void XXLinearSolve(
+  XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2,
+  XXString method, XXInteger id, XXDouble *workarray);
@@ -240,3 +244,0 @@
-
-
-
]]></failure>
  </testcase>
  <testcase
    name="common/xxmodel.h"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 92 lines"><![CDATA[--- common/xxmodel.h
+++ common/xxmodel.h.uncrustify
@@ -24,7 +24,7 @@
-	protected:
-		friend class IntegrationMethod;
-		friend class Discrete;
-		friend class Euler;
-		friend class RungeKutta2;
-		friend class RungeKutta4;
-		virtual void CalculateDynamic (void) {};
+protected:
+  friend class IntegrationMethod;
+  friend class Discrete;
+  friend class Euler;
+  friend class RungeKutta2;
+  friend class RungeKutta4;
+  virtual void CalculateDynamic(void) {}
@@ -32,7 +32,7 @@
-		bool m_initialize;
-		bool m_major;
-		bool m_stop_run;
-		XXDouble m_step_size;
-		XXDouble m_start_time;
-		XXDouble m_finish_time;
-		XXDouble m_time;
+  bool m_initialize;
+  bool m_major;
+  bool m_stop_run;
+  XXDouble m_step_size;
+  XXDouble m_start_time;
+  XXDouble m_finish_time;
+  XXDouble m_time;
@@ -40,7 +40,3 @@
-	public:
-		virtual ~Submodel20sim(){};
-		
-		XXDouble GetStepSize(void) { return m_step_size; };
-		XXDouble GetStartTime(void) { return m_start_time; };
-		XXDouble GetFinishTime(void) { return m_finish_time; };
-		XXDouble GetTime(void) { return m_time; };
+public:
+  virtual ~Submodel20sim() {
+  };
@@ -48,9 +44,4 @@
-		/* the variable count */
-		int m_number_constants;
-		int m_number_parameters;
-		int m_number_initialvalues;
-		int m_number_variables;
-		int m_number_states;
-		int m_number_rates;
-		int m_number_matrices;
-		int m_number_unnamed;
+  XXDouble GetStepSize(void) {return m_step_size;}
+  XXDouble GetStartTime(void) {return m_start_time;}
+  XXDouble GetFinishTime(void) {return m_finish_time;}
+  XXDouble GetTime(void) {return m_time;}
@@ -58,10 +49,20 @@
-		/* the variable arrays are allocated in the derived submodel class */
-		XXDouble* m_C;					/* constants */
-		XXDouble* m_P;					/* parameters */
-		XXDouble* m_I;				/* initial values */
-		XXDouble* m_V;					/* variables */
-		XXDouble* m_s;						/* states */
-		XXDouble* m_R;						/* rates (or new states) */
-		XXMatrix* m_M;					/* matrices */
-		XXDouble* m_U;					/* unnamed */
-		XXDouble* m_workarray;
+                /* the variable count */
+  int m_number_constants;
+  int m_number_parameters;
+  int m_number_initialvalues;
+  int m_number_variables;
+  int m_number_states;
+  int m_number_rates;
+  int m_number_matrices;
+  int m_number_unnamed;
+
+                /* the variable arrays are allocated in the derived submodel class */
+  XXDouble * m_C;                                               /* constants */
+  XXDouble * m_P;                                               /* parameters */
+  XXDouble * m_I;                                       /* initial values */
+  XXDouble * m_V;                                               /* variables */
+  XXDouble * m_s;                                                       /* states */
+  XXDouble * m_R;                                                       /* rates (or new states) */
+  XXMatrix * m_M;                                               /* matrices */
+  XXDouble * m_U;                                               /* unnamed */
+  XXDouble * m_workarray;
@@ -70,2 +71 @@
-#endif 	/* SUBMODEL20SIM_H */
-
+#endif  /* SUBMODEL20SIM_H */
]]></failure>
  </testcase>
  <testcase
    name="common/xxtypes.h"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 36 lines"><![CDATA[--- common/xxtypes.h
+++ common/xxtypes.h.uncrustify
@@ -18 +18 @@
-   
+
@@ -20 +20 @@
-   these types are changed! For instance, when the destination platform 
+   these types are changed! For instance, when the destination platform
@@ -26 +26 @@
-   
+
@@ -28 +28 @@
-   
+
@@ -31,3 +31,3 @@
-   
-   so that 
-   
+
+   so that
+
@@ -38 +38 @@
-*/ 
+*/
@@ -48 +48 @@
-typedef const char* XXString;
+typedef const char * XXString;
@@ -53,3 +53,3 @@
-	XXDouble *mat;
-	XXInteger rows;
-	XXInteger columns;
+  XXDouble *mat;
+  XXInteger rows;
+  XXInteger columns;
@@ -63 +62,0 @@
-
]]></failure>
  </testcase>
  <testcase
    name="include/Plant.h"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 227 lines"><![CDATA[--- include/Plant.h
+++ include/Plant.h.uncrustify
@@ -33,2 +33,2 @@
-	public:
-		enum stateflags_Plant {initialrun, mainrun, finished};
+public:
+  enum stateflags_Plant {initialrun, mainrun, finished};
@@ -36,4 +36,4 @@
-		/**
-		 * Plant constructor
-		 */
-		Plant(void);
+                /**
+                 * Plant constructor
+                 */
+  Plant(void);
@@ -41,4 +41,4 @@
-		/**
-		 * Plant destructor
-		 */
-		virtual ~Plant(void);
+                /**
+                 * Plant destructor
+                 */
+  virtual ~Plant(void);
@@ -46,7 +46,7 @@
-		/**
-		 * Plant Initialization of the model and calculation of the values for the start time t
-		 * @param u	This is the array with all input signals for this submodel
-		 * @param y	This is the array with all output signals from this submodel
-		 * @param t This is the start time for this run
-		 */
-		void Initialize (XXDouble *u, XXDouble *y, XXDouble t);
+                /**
+                 * Plant Initialization of the model and calculation of the values for the start time t
+                 * @param u	This is the array with all input signals for this submodel
+                 * @param y	This is the array with all output signals from this submodel
+                 * @param t This is the start time for this run
+                 */
+  void Initialize(XXDouble *u, XXDouble *y, XXDouble t);
@@ -54,6 +54,6 @@
-		/**
-		 * Plant Calculate
-		 * @param u	This is the array with all input signals for this submodel
-		 * @param y	This is the array with all output signals from this submodel
-		 */
-		void Calculate (XXDouble *u, XXDouble *y /*, XXDouble t*/ );
+                /**
+                 * Plant Calculate
+                 * @param u	This is the array with all input signals for this submodel
+                 * @param y	This is the array with all output signals from this submodel
+                 */
+  void Calculate(XXDouble *u, XXDouble *y /*, XXDouble t*/);
@@ -61,6 +61,6 @@
-		/**
-		 * Plant Terminate
-		 * @param u	This is the array with all input signals for this submodel
-		 * @param y	This is the array with all output signals from this submodel
-		 */
-		void Terminate (XXDouble *u, XXDouble *y /*, XXDouble t*/ );
+                /**
+                 * Plant Terminate
+                 * @param u	This is the array with all input signals for this submodel
+                 * @param y	This is the array with all output signals from this submodel
+                 */
+  void Terminate(XXDouble *u, XXDouble *y /*, XXDouble t*/);
@@ -69,7 +69,7 @@
-		/**
-		 * SetFinishTime()
-		 * @brief Overrrides the default finish time (from 20-sim) for this submodel
-		 * @param time is the wanted finish time. Use 0.0 to change it to infinite.
-		 * 
-		 */
-		bool SetFinishTime(XXDouble newtime);
+                /**
+                 * SetFinishTime()
+                 * @brief Overrrides the default finish time (from 20-sim) for this submodel
+                 * @param time is the wanted finish time. Use 0.0 to change it to infinite.
+                 *
+                 */
+  bool SetFinishTime(XXDouble newtime);
@@ -77,6 +77,6 @@
-		bool IsFinished(void);
-		/**
-		 * Reset()
-		 * @brief Resets the submodel back to its initial state for a new run
-		 */
-		void Reset(XXDouble starttime);
+  bool IsFinished(void);
+                /**
+                 * Reset()
+                 * @brief Resets the submodel back to its initial state for a new run
+                 */
+  void Reset(XXDouble starttime);
@@ -84 +84 @@
-		stateflags_Plant state;
+  stateflags_Plant state;
@@ -86,8 +86,8 @@
-	protected:
-		/**
-		 * CalculateDynamic()
-		 * This function calculates the dynamic equations of the model.
-		 * These equations are called from the integration method
-		 * to calculate the new model rates (that are then integrated).
-		 */
-		void CalculateDynamic (void);
+protected:
+                /**
+                 * CalculateDynamic()
+                 * This function calculates the dynamic equations of the model.
+                 * These equations are called from the integration method
+                 * to calculate the new model rates (that are then integrated).
+                 */
+  void CalculateDynamic(void);
@@ -95,2 +95,2 @@
-	private:
-		/* internal submodel computation methods */
+private:
+                /* internal submodel computation methods */
@@ -98,6 +98,6 @@
-		/**
-		 * CalculateInitial()
-		 * This function calculates the initial equations of the model.
-		 * These equations are calculated before anything else
-		 */
-		void CalculateInitial (void);
+                /**
+                 * CalculateInitial()
+                 * This function calculates the initial equations of the model.
+                 * These equations are calculated before anything else
+                 */
+  void CalculateInitial(void);
@@ -105,6 +105,6 @@
-		/**
-		 * CalculateStatic()
-		 * This function calculates the static equations of the model.
-		 * These equations are only dependent from parameters and constants
-		 */
-		void CalculateStatic (void);
+                /**
+                 * CalculateStatic()
+                 * This function calculates the static equations of the model.
+                 * These equations are only dependent from parameters and constants
+                 */
+  void CalculateStatic(void);
@@ -112,7 +112,7 @@
-		/**
-		 * CalculateInput()
-		 * This function calculates the input equations of the model.
-		 * These equations are dynamic equations that must not change
-		 * in calls from the integration method (like random and delay).
-		 */
-		void CalculateInput (void);
+                /**
+                 * CalculateInput()
+                 * This function calculates the input equations of the model.
+                 * These equations are dynamic equations that must not change
+                 * in calls from the integration method (like random and delay).
+                 */
+  void CalculateInput(void);
@@ -120,9 +120,9 @@
-		/**
-		 * CalculateOutput()
-		 * This function calculates the output equations of the model.
-		 * These equations are not needed for calculation of the rates
-		 * and are kept separate to make the dynamic set of equations smaller.
-		 * These dynamic equations are called often more than one time for each
-		 * integration step that is taken. This makes model computation much faster.
-		 */
-		void CalculateOutput (void);
+                /**
+                 * CalculateOutput()
+                 * This function calculates the output equations of the model.
+                 * These equations are not needed for calculation of the rates
+                 * and are kept separate to make the dynamic set of equations smaller.
+                 * These dynamic equations are called often more than one time for each
+                 * integration step that is taken. This makes model computation much faster.
+                 */
+  void CalculateOutput(void);
@@ -130,7 +130,7 @@
-		/**
-		 * CalculateFinal()
-		 * This function calculates the final equations of the model.
-		 * These equations are calculated after all the calculations
-		 * are performed
-		 */
-		void CalculateFinal (void);
+                /**
+                 * CalculateFinal()
+                 * This function calculates the final equations of the model.
+                 * These equations are calculated after all the calculations
+                 * are performed
+                 */
+  void CalculateFinal(void);
@@ -138,6 +138,6 @@
-		/**
-		 * CopyInputsToVariables
-		 * This private function copies the input variables from the input vector
-		 * @param u	This is the array with all input signals for this submodel
-		 */
-		void CopyInputsToVariables (XXDouble *u);
+                /**
+                 * CopyInputsToVariables
+                 * This private function copies the input variables from the input vector
+                 * @param u	This is the array with all input signals for this submodel
+                 */
+  void CopyInputsToVariables(XXDouble *u);
@@ -145,6 +145,6 @@
-		/**
-		 * CopyVariablesToOutputs
-		 * This private function copies the output variables to the output vector
-		 * @param y	This is the array with all output signals from this submodel
-		 */
-		void CopyVariablesToOutputs (XXDouble *y);
+                /**
+                 * CopyVariablesToOutputs
+                 * This private function copies the output variables to the output vector
+                 * @param y	This is the array with all output signals from this submodel
+                 */
+  void CopyVariablesToOutputs(XXDouble *y);
@@ -153 +153 @@
-		RungeKutta4 myintegmethod;	///< pointer to the integration method for this submodel
+  RungeKutta4 myintegmethod;                    ///< pointer to the integration method for this submodel
@@ -156,2 +156 @@
-#endif	/* Plant_H */
-
+#endif  /* Plant_H */
]]></failure>
  </testcase>
  <testcase
    name="include/relbot_simulator.hpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 10 lines"><![CDATA[--- include/relbot_simulator.hpp
+++ include/relbot_simulator.hpp.uncrustify
@@ -203 +203,3 @@
-  cv::Mat CreateCVSubimage(const sensor_msgs::msg::Image::SharedPtr msg_cam_img, const int center_pixel_x, const int center_pixel_y, int output_image_dim);
+  cv::Mat CreateCVSubimage(
+    const sensor_msgs::msg::Image::SharedPtr msg_cam_img,
+    const int center_pixel_x, const int center_pixel_y, int output_image_dim);
@@ -205 +207 @@
-#endif /* RELBOT_SIMULATOR_HPP_ */+#endif /* RELBOT_SIMULATOR_HPP_ */
]]></failure>
  </testcase>
  <testcase
    name="src/Plant.cpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 1332 lines"><![CDATA[--- src/Plant.cpp
+++ src/Plant.cpp.uncrustify
@@ -30,5 +30,5 @@
-void Plant::CopyInputsToVariables (XXDouble *u)
-{
-	/* copy the input vector to the input variables */
-	m_V[90] = u[0];		/* steer_left */
-	m_V[91] = u[1];		/* steer_right */
+void Plant::CopyInputsToVariables(XXDouble *u)
+{
+        /* copy the input vector to the input variables */
+  m_V[90] = u[0];               /* steer_left */
+  m_V[91] = u[1];               /* steer_right */
@@ -39,8 +39,8 @@
-void Plant::CopyVariablesToOutputs (XXDouble *y)
-{
-	/* copy the output variables to the output vector */
-	y[0] = 	m_V[87];		/* a_pos_feedback_left */
-	y[1] = 	m_V[88];		/* b_pos_feedback_right */
-	y[2] = 	m_V[85];		/* c_position_x {m} */
-	y[3] = 	m_V[86];		/* d_position_y {m} */
-	y[4] = 	m_V[89];		/* e_theta_z {rad} */
+void Plant::CopyVariablesToOutputs(XXDouble *y)
+{
+        /* copy the output variables to the output vector */
+  y[0] = m_V[87];                       /* a_pos_feedback_left */
+  y[1] = m_V[88];                       /* b_pos_feedback_right */
+  y[2] = m_V[85];                       /* c_position_x {m} */
+  y[3] = m_V[86];                       /* d_position_y {m} */
+  y[4] = m_V[89];                       /* e_theta_z {rad} */
@@ -52,22 +52,22 @@
-	m_number_constants = 0;
-	m_number_parameters = 36;
-	m_number_initialvalues = 14;
-	m_number_variables = 92;
-	m_number_states = 14;
-	m_number_rates = 14;
-	m_number_matrices = 24;
-	m_number_unnamed = 22;
-
-	/* the variable arrays */
-	m_C = new XXDouble[0 + 1];		/* constants */
-	m_P = new XXDouble[36 + 1];		/* parameters */
-	m_I = new XXDouble[14 + 1];		/* initial values */
-	m_V = new XXDouble[92 + 1];		/* variables */
-	m_s = new XXDouble[14 + 1];		/* states */
-	m_R = new XXDouble[14 + 1];		/* rates (or new states) */
-	m_M = new XXMatrix[24 + 1];		/* matrices */
-	m_U = new XXDouble[22 + 1];		/* unnamed */
-	m_workarray = new XXDouble[20 + 1];
-
-	Reset(0.0);
-	m_finish_time = 550.0;
+  m_number_constants = 0;
+  m_number_parameters = 36;
+  m_number_initialvalues = 14;
+  m_number_variables = 92;
+  m_number_states = 14;
+  m_number_rates = 14;
+  m_number_matrices = 24;
+  m_number_unnamed = 22;
+
+        /* the variable arrays */
+  m_C = new XXDouble[0 + 1];                    /* constants */
+  m_P = new XXDouble[36 + 1];                   /* parameters */
+  m_I = new XXDouble[14 + 1];                   /* initial values */
+  m_V = new XXDouble[92 + 1];                   /* variables */
+  m_s = new XXDouble[14 + 1];                   /* states */
+  m_R = new XXDouble[14 + 1];                   /* rates (or new states) */
+  m_M = new XXMatrix[24 + 1];                   /* matrices */
+  m_U = new XXDouble[22 + 1];                   /* unnamed */
+  m_workarray = new XXDouble[20 + 1];
+
+  Reset(0.0);
+  m_finish_time = 550.0;
@@ -78,19 +78,19 @@
-	m_start_time = starttime;
-	m_step_size = 0.001;
-	m_time = starttime;
-	m_major = true;
-	m_stop_run = false;
-
-	/* Clear the allocated variable memory */
-	memset(m_C, 0, (0 + 1) * sizeof(XXDouble));
-	memset(m_P, 0, (36 + 1) * sizeof(XXDouble));
-	memset(m_I, 0, (14 + 1) * sizeof(XXDouble));
-	memset(m_V, 0, (92 + 1) * sizeof(XXDouble));
-	memset(m_s, 0, (14 + 1) * sizeof(XXDouble));
-	memset(m_R, 0, (14 + 1) * sizeof(XXDouble));
-	memset(m_M, 0, (24 + 1) * sizeof(XXDouble));
-	memset(m_U, 0, (22 + 1) * sizeof(XXDouble));
-	memset(m_workarray, 0, (20 + 1) * sizeof(XXDouble));
-
-
-	state = initialrun;
+  m_start_time = starttime;
+  m_step_size = 0.001;
+  m_time = starttime;
+  m_major = true;
+  m_stop_run = false;
+
+        /* Clear the allocated variable memory */
+  memset(m_C, 0, (0 + 1) * sizeof(XXDouble));
+  memset(m_P, 0, (36 + 1) * sizeof(XXDouble));
+  memset(m_I, 0, (14 + 1) * sizeof(XXDouble));
+  memset(m_V, 0, (92 + 1) * sizeof(XXDouble));
+  memset(m_s, 0, (14 + 1) * sizeof(XXDouble));
+  memset(m_R, 0, (14 + 1) * sizeof(XXDouble));
+  memset(m_M, 0, (24 + 1) * sizeof(XXDouble));
+  memset(m_U, 0, (22 + 1) * sizeof(XXDouble));
+  memset(m_workarray, 0, (20 + 1) * sizeof(XXDouble));
+
+
+  state = initialrun;
@@ -101 +101 @@
-	return (state == finished);
+  return  state == finished;
@@ -106,10 +106,10 @@
-	/* free memory */
-	delete[] m_C;
-	delete[] m_P;
-	delete[] m_I;
-	delete[] m_V;
-	delete[] m_s;
-	delete[] m_R;
-	delete[] m_M;
-	delete[] m_U;
-	delete[] m_workarray;
+        /* free memory */
+  delete[] m_C;
+  delete[] m_P;
+  delete[] m_I;
+  delete[] m_V;
+  delete[] m_s;
+  delete[] m_R;
+  delete[] m_M;
+  delete[] m_U;
+  delete[] m_workarray;
@@ -119,200 +119,200 @@
-void Plant::Initialize (XXDouble *u, XXDouble *y, XXDouble t)
-{
-	/* initialization phase (allocating memory) */
-	m_initialize = true;
-	m_stop_run = false;
-
-	/* set the constants */
-
-
-	/* set the parameters */
-	m_P[0] = 0.021;		/* Drivetrain_left\DeadZone1\zone */
-	m_P[1] = -12.0;		/* Drivetrain_left\DutycycleToVolt\K */
-	m_P[2] = 0.003240977777777778;		/* Drivetrain_left\Gain\K */
-	m_P[3] = 0.0246;		/* Drivetrain_left\gy_motor_constant_left\r */
-	m_P[4] = 3.5005237381150026e-6;		/* Drivetrain_left\J_rotor_left\i */
-	m_P[5] = 2.14;		/* Drivetrain_left\R_actuator_left\r */
-	m_P[6] = 3.33348e-6;		/* Drivetrain_left\R_rotational_friction_left\r */
-	m_P[7] = 0.06417777777777778;		/* Drivetrain_left\tf_gearbox_reduction_left\r */
-	m_P[8] = 0.021;		/* Drivetrain_right\DeadZone2\zone */
-	m_P[9] = -12.0;		/* Drivetrain_right\DutycycleToVolt\K */
-	m_P[10] = 0.003240977777777778;		/* Drivetrain_right\Gain\K */
-	m_P[11] = 0.0246;		/* Drivetrain_right\gy_motor_constant_right\r */
-	m_P[12] = 3.5005237381150026e-6;		/* Drivetrain_right\J_rotor_right\i */
-	m_P[13] = 2.14;		/* Drivetrain_right\R_actuator_right\r */
-	m_P[14] = 3.33348e-6;		/* Drivetrain_right\R_rotational_friction_right\r */
-	m_P[15] = 0.06417777777777778;		/* Drivetrain_right\tf_gearbox_reduction_right\r */
-	m_P[16] = 1.0e-4;		/* Rigid_body\c_x_left\spring */
-	m_P[17] = 1.0e-4;		/* Rigid_body\c_x_right\spring */
-	m_P[18] = 1.0e-4;		/* Rigid_body\c_y_left\spring */
-	m_P[19] = 1.0e-4;		/* Rigid_body\c_y_right\spring */
-	m_P[20] = 0.072388;		/* Rigid_body\J_RELbot\i */
-	m_P[21] = 1.288;		/* Rigid_body\m_RELbot\m */
-	m_P[22] = 100.0;		/* Rigid_body\r_x_left\r */
-	m_P[23] = 100.0;		/* Rigid_body\r_x_right\r */
-	m_P[24] = 100.0;		/* Rigid_body\r_y_left\r */
-	m_P[25] = 100.0;		/* Rigid_body\r_y_right\r */
-	m_P[26] = 0.0;		/* ly_offset */
-	m_P[27] = 0.02;		/* lx_offset */
-	m_P[28] = -0.104;		/* Rigid_body\tf_wheel_left_wrt_CoM\r */
-	m_P[29] = 0.06175;		
-	m_P[30] = 0.104;		/* Rigid_body\tf_wheel_right_wrt_CoM\r */
-	m_P[31] = 0.06175;		
-	m_P[32] = 0.008;		/* Wheel_left\R_rotational_friction_left\r */
-	m_P[33] = 0.0505;		/* Wheel_left\tf_rotation_to_translation_left\r */
-	m_P[34] = 0.008;		/* Wheel_right\R_rotational_friction_right\r */
-	m_P[35] = 0.0505;		/* Wheel_right\tf_rotation_to_translation_right\r */
-
-
-	/* set the initial values */
-	m_I[0] = 0.0;		/* Drivetrain_left\Integrate\initial */
-	m_I[1] = 0.0;		/* Drivetrain_left\J_rotor_left\state_initial */
-	m_I[2] = 0.0;		/* Drivetrain_right\Integrate\initial */
-	m_I[3] = 0.0;		/* Drivetrain_right\J_rotor_right\state_initial */
-	m_I[4] = 0.0;		/* Rigid_body\AngleBody\initial */
-	m_I[5] = 0.0;		/* Rigid_body\c_x_left\state_initial */
-	m_I[6] = 0.0;		/* Rigid_body\c_x_right\state_initial */
-	m_I[7] = 0.0;		/* Rigid_body\c_y_left\state_initial */
-	m_I[8] = 0.0;		/* Rigid_body\c_y_right\state_initial */
-	m_I[9] = 0.0;		/* Rigid_body\InertialPosition\initial1 */
-	m_I[10] = 0.0;		/* Rigid_body\InertialPosition\initial2 */
-	m_I[11] = 0.0;		/* Rigid_body\J_RELbot\state_initial */
-	m_I[12] = 0.0;		/* Rigid_body\m_RELbot\state_initial */
-	m_I[13] = 0.0;		
-
-
-	/* set the states */
-	m_s[0] = m_I[0];		/* Drivetrain_left\Integrate\output */
-	m_s[1] = m_I[1];		/* Drivetrain_left\J_rotor_left\state */
-	m_s[2] = m_I[2];		/* Drivetrain_right\Integrate\output */
-	m_s[3] = m_I[3];		/* Drivetrain_right\J_rotor_right\state */
-	m_s[4] = m_I[4];		/* Rigid_body\AngleBody\output {rad} */
-	m_s[5] = m_I[5];		/* Rigid_body\c_x_left\state */
-	m_s[6] = m_I[6];		/* Rigid_body\c_x_right\state */
-	m_s[7] = m_I[7];		/* Rigid_body\c_y_left\state */
-	m_s[8] = m_I[8];		/* Rigid_body\c_y_right\state */
-	m_s[9] = m_I[9];		/* Rigid_body\InertialPosition\initial1_int */
-	m_s[10] = m_I[10];		/* Rigid_body\InertialPosition\initial2_int */
-	m_s[11] = m_I[11];		/* Rigid_body\J_RELbot\state */
-	m_s[12] = m_I[12];		/* Rigid_body\m_RELbot\state */
-	m_s[13] = m_I[13];
-
-
-	/* set the matrices */
-	m_M[0].mat = &m_V[30];		/* Rigid_body\InertialPosition\output */
-	m_M[0].rows = 2;
-	m_M[0].columns = 1;
-	m_M[1].mat = &m_V[32];		/* Rigid_body\m_RELbot\p.f */
-	m_M[1].rows = 2;
-	m_M[1].columns = 1;
-	m_M[2].mat = &m_V[34];		/* Rigid_body\m_RELbot\i */
-	m_M[2].rows = 2;
-	m_M[2].columns = 2;
-	m_M[3].mat = &m_V[44];		/* Rigid_body\PowerDemuxLeft\input.e */
-	m_M[3].rows = 2;
-	m_M[3].columns = 1;
-	m_M[4].mat = &m_V[48];		/* Rigid_body\PowerDemuxLeft1\input.e */
-	m_M[4].rows = 2;
-	m_M[4].columns = 1;
-	m_M[5].mat = &m_V[52];		/* Rigid_body\PowerDemuxRight\input.e */
-	m_M[5].rows = 2;
-	m_M[5].columns = 1;
-	m_M[6].mat = &m_V[56];		/* Rigid_body\PowerDemuxRight1\input.e */
-	m_M[6].rows = 2;
-	m_M[6].columns = 1;
-	m_M[7].mat = &m_V[59];		/* Rigid_body\RTF\p1.f */
-	m_M[7].rows = 2;
-	m_M[7].columns = 1;
-	m_M[8].mat = &m_V[61];		/* Rigid_body\RTF\r */
-	m_M[8].rows = 2;
-	m_M[8].columns = 2;
-	m_M[9].mat = &m_V[70];		/* Rigid_body\tf_wheel_left_wrt_CoM\p2.f */
-	m_M[9].rows = 2;
-	m_M[9].columns = 1;
-	m_M[10].mat = &m_P[28];		/* Rigid_body\tf_wheel_left_wrt_CoM\r */
-	m_M[10].rows = 2;
-	m_M[10].columns = 1;
-	m_M[11].mat = &m_V[73];		/* Rigid_body\tf_wheel_right_wrt_CoM\p2.f */
-	m_M[11].rows = 2;
-	m_M[11].columns = 1;
-	m_M[12].mat = &m_P[30];		/* Rigid_body\tf_wheel_right_wrt_CoM\r */
-	m_M[12].rows = 2;
-	m_M[12].columns = 1;
-	m_M[13].mat = &m_V[75];		/* Rigid_body\v_xy_CoM\p3.e */
-	m_M[13].rows = 2;
-	m_M[13].columns = 1;
-	m_M[14].mat = &m_R[12];		/* Rigid_body\m_RELbot\p.e */
-	m_M[14].rows = 2;
-	m_M[14].columns = 1;
-	m_M[15].mat = &m_s[12];		/* Rigid_body\m_RELbot\state */
-	m_M[15].rows = 2;
-	m_M[15].columns = 1;
-	m_M[16].mat = &m_I[12];		/* Rigid_body\m_RELbot\state_initial */
-	m_M[16].rows = 2;
-	m_M[16].columns = 1;
-	m_M[17].mat = &m_U[0];		/* m_U1 */
-	m_M[17].rows = 2;
-	m_M[17].columns = 2;
-	m_M[18].mat = &m_U[4];		/* m_U2 */
-	m_M[18].rows = 2;
-	m_M[18].columns = 2;
-	m_M[19].mat = &m_U[8];		/* m_U3 */
-	m_M[19].rows = 1;
-	m_M[19].columns = 2;
-	m_M[20].mat = &m_U[10];		/* m_U4 */
-	m_M[20].rows = 1;
-	m_M[20].columns = 2;
-	m_M[21].mat = &m_U[12];		/* m_U5 */
-	m_M[21].rows = 2;
-	m_M[21].columns = 1;
-	m_M[22].mat = &m_U[14];		/* m_U6 */
-	m_M[22].rows = 2;
-	m_M[22].columns = 2;
-	m_M[23].mat = &m_U[18];		/* m_U7 */
-	m_M[23].rows = 2;
-	m_M[23].columns = 2;
-
-
-	/* (re-)initialize the integration method */
-	myintegmethod.Initialize(this);
-	
-	/* copy the inputs */
-	m_time = t;
-	CopyInputsToVariables (u);
-
-	/* calculate initial equations */
-	CalculateInitial ();
-
-	/* set the states again, they might have changed in the initial calculation */
-	m_s[0] = m_I[0];		/* Drivetrain_left\Integrate\output */
-	m_s[1] = m_I[1];		/* Drivetrain_left\J_rotor_left\state */
-	m_s[2] = m_I[2];		/* Drivetrain_right\Integrate\output */
-	m_s[3] = m_I[3];		/* Drivetrain_right\J_rotor_right\state */
-	m_s[4] = m_I[4];		/* Rigid_body\AngleBody\output {rad} */
-	m_s[5] = m_I[5];		/* Rigid_body\c_x_left\state */
-	m_s[6] = m_I[6];		/* Rigid_body\c_x_right\state */
-	m_s[7] = m_I[7];		/* Rigid_body\c_y_left\state */
-	m_s[8] = m_I[8];		/* Rigid_body\c_y_right\state */
-	m_s[9] = m_I[9];		/* Rigid_body\InertialPosition\initial1_int */
-	m_s[10] = m_I[10];		/* Rigid_body\InertialPosition\initial2_int */
-	m_s[11] = m_I[11];		/* Rigid_body\J_RELbot\state */
-	m_s[12] = m_I[12];		/* Rigid_body\m_RELbot\state */
-	m_s[13] = m_I[13];
-
-
-	/* calculate static equations */
-	CalculateStatic ();
-	/* calculate input equations */
-	CalculateInput ();
-	/* calculate dynamic equations */
-	CalculateDynamic ();
-	/* calculate output equations */
-	CalculateOutput ();
-
-	/* Set the outputs */
-	CopyVariablesToOutputs (y);
-
-	/* end of initialization phase */
-	m_initialize = false;
-
-	state = mainrun;
+void Plant::Initialize(XXDouble *u, XXDouble *y, XXDouble t)
+{
+        /* initialization phase (allocating memory) */
+  m_initialize = true;
+  m_stop_run = false;
+
+        /* set the constants */
+
+
+        /* set the parameters */
+  m_P[0] = 0.021;               /* Drivetrain_left\DeadZone1\zone */
+  m_P[1] = -12.0;               /* Drivetrain_left\DutycycleToVolt\K */
+  m_P[2] = 0.003240977777777778;                /* Drivetrain_left\Gain\K */
+  m_P[3] = 0.0246;                      /* Drivetrain_left\gy_motor_constant_left\r */
+  m_P[4] = 3.5005237381150026e-6;               /* Drivetrain_left\J_rotor_left\i */
+  m_P[5] = 2.14;                /* Drivetrain_left\R_actuator_left\r */
+  m_P[6] = 3.33348e-6;                  /* Drivetrain_left\R_rotational_friction_left\r */
+  m_P[7] = 0.06417777777777778;                 /* Drivetrain_left\tf_gearbox_reduction_left\r */
+  m_P[8] = 0.021;               /* Drivetrain_right\DeadZone2\zone */
+  m_P[9] = -12.0;               /* Drivetrain_right\DutycycleToVolt\K */
+  m_P[10] = 0.003240977777777778;               /* Drivetrain_right\Gain\K */
+  m_P[11] = 0.0246;                     /* Drivetrain_right\gy_motor_constant_right\r */
+  m_P[12] = 3.5005237381150026e-6;                      /* Drivetrain_right\J_rotor_right\i */
+  m_P[13] = 2.14;               /* Drivetrain_right\R_actuator_right\r */
+  m_P[14] = 3.33348e-6;                 /* Drivetrain_right\R_rotational_friction_right\r */
+  m_P[15] = 0.06417777777777778;                /* Drivetrain_right\tf_gearbox_reduction_right\r */
+  m_P[16] = 1.0e-4;                     /* Rigid_body\c_x_left\spring */
+  m_P[17] = 1.0e-4;                     /* Rigid_body\c_x_right\spring */
+  m_P[18] = 1.0e-4;                     /* Rigid_body\c_y_left\spring */
+  m_P[19] = 1.0e-4;                     /* Rigid_body\c_y_right\spring */
+  m_P[20] = 0.072388;                   /* Rigid_body\J_RELbot\i */
+  m_P[21] = 1.288;                      /* Rigid_body\m_RELbot\m */
+  m_P[22] = 100.0;                      /* Rigid_body\r_x_left\r */
+  m_P[23] = 100.0;                      /* Rigid_body\r_x_right\r */
+  m_P[24] = 100.0;                      /* Rigid_body\r_y_left\r */
+  m_P[25] = 100.0;                      /* Rigid_body\r_y_right\r */
+  m_P[26] = 0.0;                /* ly_offset */
+  m_P[27] = 0.02;               /* lx_offset */
+  m_P[28] = -0.104;                     /* Rigid_body\tf_wheel_left_wrt_CoM\r */
+  m_P[29] = 0.06175;
+  m_P[30] = 0.104;                      /* Rigid_body\tf_wheel_right_wrt_CoM\r */
+  m_P[31] = 0.06175;
+  m_P[32] = 0.008;                      /* Wheel_left\R_rotational_friction_left\r */
+  m_P[33] = 0.0505;                     /* Wheel_left\tf_rotation_to_translation_left\r */
+  m_P[34] = 0.008;                      /* Wheel_right\R_rotational_friction_right\r */
+  m_P[35] = 0.0505;                     /* Wheel_right\tf_rotation_to_translation_right\r */
+
+
+        /* set the initial values */
+  m_I[0] = 0.0;                 /* Drivetrain_left\Integrate\initial */
+  m_I[1] = 0.0;                 /* Drivetrain_left\J_rotor_left\state_initial */
+  m_I[2] = 0.0;                 /* Drivetrain_right\Integrate\initial */
+  m_I[3] = 0.0;                 /* Drivetrain_right\J_rotor_right\state_initial */
+  m_I[4] = 0.0;                 /* Rigid_body\AngleBody\initial */
+  m_I[5] = 0.0;                 /* Rigid_body\c_x_left\state_initial */
+  m_I[6] = 0.0;                 /* Rigid_body\c_x_right\state_initial */
+  m_I[7] = 0.0;                 /* Rigid_body\c_y_left\state_initial */
+  m_I[8] = 0.0;                 /* Rigid_body\c_y_right\state_initial */
+  m_I[9] = 0.0;                 /* Rigid_body\InertialPosition\initial1 */
+  m_I[10] = 0.0;                /* Rigid_body\InertialPosition\initial2 */
+  m_I[11] = 0.0;                /* Rigid_body\J_RELbot\state_initial */
+  m_I[12] = 0.0;                /* Rigid_body\m_RELbot\state_initial */
+  m_I[13] = 0.0;
+
+
+        /* set the states */
+  m_s[0] = m_I[0];                      /* Drivetrain_left\Integrate\output */
+  m_s[1] = m_I[1];                      /* Drivetrain_left\J_rotor_left\state */
+  m_s[2] = m_I[2];                      /* Drivetrain_right\Integrate\output */
+  m_s[3] = m_I[3];                      /* Drivetrain_right\J_rotor_right\state */
+  m_s[4] = m_I[4];                      /* Rigid_body\AngleBody\output {rad} */
+  m_s[5] = m_I[5];                      /* Rigid_body\c_x_left\state */
+  m_s[6] = m_I[6];                      /* Rigid_body\c_x_right\state */
+  m_s[7] = m_I[7];                      /* Rigid_body\c_y_left\state */
+  m_s[8] = m_I[8];                      /* Rigid_body\c_y_right\state */
+  m_s[9] = m_I[9];                      /* Rigid_body\InertialPosition\initial1_int */
+  m_s[10] = m_I[10];                    /* Rigid_body\InertialPosition\initial2_int */
+  m_s[11] = m_I[11];                    /* Rigid_body\J_RELbot\state */
+  m_s[12] = m_I[12];                    /* Rigid_body\m_RELbot\state */
+  m_s[13] = m_I[13];
+
+
+        /* set the matrices */
+  m_M[0].mat = &m_V[30];                /* Rigid_body\InertialPosition\output */
+  m_M[0].rows = 2;
+  m_M[0].columns = 1;
+  m_M[1].mat = &m_V[32];                /* Rigid_body\m_RELbot\p.f */
+  m_M[1].rows = 2;
+  m_M[1].columns = 1;
+  m_M[2].mat = &m_V[34];                /* Rigid_body\m_RELbot\i */
+  m_M[2].rows = 2;
+  m_M[2].columns = 2;
+  m_M[3].mat = &m_V[44];                /* Rigid_body\PowerDemuxLeft\input.e */
+  m_M[3].rows = 2;
+  m_M[3].columns = 1;
+  m_M[4].mat = &m_V[48];                /* Rigid_body\PowerDemuxLeft1\input.e */
+  m_M[4].rows = 2;
+  m_M[4].columns = 1;
+  m_M[5].mat = &m_V[52];                /* Rigid_body\PowerDemuxRight\input.e */
+  m_M[5].rows = 2;
+  m_M[5].columns = 1;
+  m_M[6].mat = &m_V[56];                /* Rigid_body\PowerDemuxRight1\input.e */
+  m_M[6].rows = 2;
+  m_M[6].columns = 1;
+  m_M[7].mat = &m_V[59];                /* Rigid_body\RTF\p1.f */
+  m_M[7].rows = 2;
+  m_M[7].columns = 1;
+  m_M[8].mat = &m_V[61];                /* Rigid_body\RTF\r */
+  m_M[8].rows = 2;
+  m_M[8].columns = 2;
+  m_M[9].mat = &m_V[70];                /* Rigid_body\tf_wheel_left_wrt_CoM\p2.f */
+  m_M[9].rows = 2;
+  m_M[9].columns = 1;
+  m_M[10].mat = &m_P[28];               /* Rigid_body\tf_wheel_left_wrt_CoM\r */
+  m_M[10].rows = 2;
+  m_M[10].columns = 1;
+  m_M[11].mat = &m_V[73];               /* Rigid_body\tf_wheel_right_wrt_CoM\p2.f */
+  m_M[11].rows = 2;
+  m_M[11].columns = 1;
+  m_M[12].mat = &m_P[30];               /* Rigid_body\tf_wheel_right_wrt_CoM\r */
+  m_M[12].rows = 2;
+  m_M[12].columns = 1;
+  m_M[13].mat = &m_V[75];               /* Rigid_body\v_xy_CoM\p3.e */
+  m_M[13].rows = 2;
+  m_M[13].columns = 1;
+  m_M[14].mat = &m_R[12];               /* Rigid_body\m_RELbot\p.e */
+  m_M[14].rows = 2;
+  m_M[14].columns = 1;
+  m_M[15].mat = &m_s[12];               /* Rigid_body\m_RELbot\state */
+  m_M[15].rows = 2;
+  m_M[15].columns = 1;
+  m_M[16].mat = &m_I[12];               /* Rigid_body\m_RELbot\state_initial */
+  m_M[16].rows = 2;
+  m_M[16].columns = 1;
+  m_M[17].mat = &m_U[0];                /* m_U1 */
+  m_M[17].rows = 2;
+  m_M[17].columns = 2;
+  m_M[18].mat = &m_U[4];                /* m_U2 */
+  m_M[18].rows = 2;
+  m_M[18].columns = 2;
+  m_M[19].mat = &m_U[8];                /* m_U3 */
+  m_M[19].rows = 1;
+  m_M[19].columns = 2;
+  m_M[20].mat = &m_U[10];               /* m_U4 */
+  m_M[20].rows = 1;
+  m_M[20].columns = 2;
+  m_M[21].mat = &m_U[12];               /* m_U5 */
+  m_M[21].rows = 2;
+  m_M[21].columns = 1;
+  m_M[22].mat = &m_U[14];               /* m_U6 */
+  m_M[22].rows = 2;
+  m_M[22].columns = 2;
+  m_M[23].mat = &m_U[18];               /* m_U7 */
+  m_M[23].rows = 2;
+  m_M[23].columns = 2;
+
+
+        /* (re-)initialize the integration method */
+  myintegmethod.Initialize(this);
+
+        /* copy the inputs */
+  m_time = t;
+  CopyInputsToVariables (u);
+
+        /* calculate initial equations */
+  CalculateInitial ();
+
+        /* set the states again, they might have changed in the initial calculation */
+  m_s[0] = m_I[0];                      /* Drivetrain_left\Integrate\output */
+  m_s[1] = m_I[1];                      /* Drivetrain_left\J_rotor_left\state */
+  m_s[2] = m_I[2];                      /* Drivetrain_right\Integrate\output */
+  m_s[3] = m_I[3];                      /* Drivetrain_right\J_rotor_right\state */
+  m_s[4] = m_I[4];                      /* Rigid_body\AngleBody\output {rad} */
+  m_s[5] = m_I[5];                      /* Rigid_body\c_x_left\state */
+  m_s[6] = m_I[6];                      /* Rigid_body\c_x_right\state */
+  m_s[7] = m_I[7];                      /* Rigid_body\c_y_left\state */
+  m_s[8] = m_I[8];                      /* Rigid_body\c_y_right\state */
+  m_s[9] = m_I[9];                      /* Rigid_body\InertialPosition\initial1_int */
+  m_s[10] = m_I[10];                    /* Rigid_body\InertialPosition\initial2_int */
+  m_s[11] = m_I[11];                    /* Rigid_body\J_RELbot\state */
+  m_s[12] = m_I[12];                    /* Rigid_body\m_RELbot\state */
+  m_s[13] = m_I[13];
+
+
+        /* calculate static equations */
+  CalculateStatic ();
+        /* calculate input equations */
+  CalculateInput ();
+        /* calculate dynamic equations */
+  CalculateDynamic ();
+        /* calculate output equations */
+  CalculateOutput ();
+
+        /* Set the outputs */
+  CopyVariablesToOutputs (y);
+
+        /* end of initialization phase */
+  m_initialize = false;
+
+  state = mainrun;
@@ -322,34 +322,31 @@
-void Plant::Calculate (XXDouble *u, XXDouble *y /*, XXDouble t*/)
-{
-	switch (state)
-	{
-		case initialrun:	/* calculate the model for the first time */
-			Initialize(u, y, 0.0);
-			break;
-		case mainrun:	/* calculate the model */
-			if ( ( m_time <= (m_finish_time - m_step_size  + c_delta )) || ( m_finish_time == 0.0 ) )
-			{
-				/* another precessor submodel could determine the parameters of this submodel
-				   and therefore the static parameter calculations need to be performed. */
-				CalculateStatic ();
-				CopyInputsToVariables (u);
-				CalculateInput ();
-				myintegmethod.Step();
-				CalculateOutput ();
-				CopyVariablesToOutputs (y);
-			}
-			else
-			{
-				state = finished;
-			}
-
-			if ( ( m_stop_run == true ) || (( m_finish_time != 0.0 ) && ( m_time + c_delta >= m_finish_time)) )
-			{
-				state = finished;
-			}
-			break;
-		case finished:
-			break;
-		default:
-			break;
-	}
+void Plant::Calculate(XXDouble *u, XXDouble *y /*, XXDouble t*/)
+{
+  switch (state) {
+    case initialrun:                    /* calculate the model for the first time */
+      Initialize(u, y, 0.0);
+      break;
+    case mainrun:               /* calculate the model */
+      if ( ( m_time <= (m_finish_time - m_step_size + c_delta )) || ( m_finish_time == 0.0 ) ) {
+                                /* another precessor submodel could determine the parameters of this submodel
+                                   and therefore the static parameter calculations need to be performed. */
+        CalculateStatic ();
+        CopyInputsToVariables (u);
+        CalculateInput ();
+        myintegmethod.Step();
+        CalculateOutput ();
+        CopyVariablesToOutputs (y);
+      } else {
+        state = finished;
+      }
+
+      if ( ( m_stop_run == true ) ||
+        (( m_finish_time != 0.0 ) && ( m_time + c_delta >= m_finish_time)) )
+      {
+        state = finished;
+      }
+      break;
+    case finished:
+      break;
+    default:
+      break;
+  }
@@ -359,10 +356,10 @@
-void Plant::Terminate (XXDouble *u, XXDouble *y /*, XXDouble t */)
-{
-	/* copy the inputs */
-	CopyInputsToVariables (u);
-
-	/* calculate the final model equations */
-	CalculateFinal ();
-
-	/* set the outputs */
-	CopyVariablesToOutputs (y);
+void Plant::Terminate(XXDouble *u, XXDouble *y /*, XXDouble t */)
+{
+        /* copy the inputs */
+  CopyInputsToVariables (u);
+
+        /* calculate the final model equations */
+  CalculateFinal ();
+
+        /* set the outputs */
+  CopyVariablesToOutputs (y);
@@ -375,33 +372,35 @@
-void Plant::CalculateInitial (void)
-{
-		/* Drivetrain_left\Gain\K = (((real) 361 / 5625) * 0.101) / 2; */
-		m_P[2] = (((XXDouble) 361.0 / 5625.0) * 0.101) / 2.0;
-
-		/* Drivetrain_left\J_rotor_left\i = (1.49e-6 + (4.28e-4 + (0.02358) * 0.0505 ^ 2) * ((real) 361 / 5625) ^ 2); */
-		m_P[4] = (1.49e-6 + (4.28e-4 + (0.02358) * (0.0505 * 0.0505)) * XXPow2 (((XXDouble) 361.0 / 5625.0)));
-
-		/* Drivetrain_left\tf_gearbox_reduction_left\r = (real) 361 / 5625; */
-		m_P[7] = (XXDouble) 361.0 / 5625.0;
-
-		/* Drivetrain_right\Gain\K = (((real) 361 / 5625) * 0.101) / 2; */
-		m_P[10] = (((XXDouble) 361.0 / 5625.0) * 0.101) / 2.0;
-
-		/* Drivetrain_right\J_rotor_right\i = (1.49e-6 + (4.28e-4 + (0.02358) * 0.0505 ^ 2) * ((real) 361 / 5625) ^ 2); */
-		m_P[12] = (1.49e-6 + (4.28e-4 + (0.02358) * (0.0505 * 0.0505)) * XXPow2 (((XXDouble) 361.0 / 5625.0)));
-
-		/* Drivetrain_right\tf_gearbox_reduction_right\r = (real) 361 / 5625; */
-		m_P[15] = (XXDouble) 361.0 / 5625.0;
-
-		/* Rigid_body\tf_wheel_left_wrt_CoM\r = [-0.104 - ly_offset; 0.04175 + lx_offset]; */
-		m_M[10].mat[0] = -0.104 - m_P[26];
-		m_M[10].mat[1] = 0.04175 + m_P[27];
-
-		/* Rigid_body\tf_wheel_right_wrt_CoM\r = [0.104 - ly_offset; 0.04175 + lx_offset]; */
-		m_M[12].mat[0] = 0.104 - m_P[26];
-		m_M[12].mat[1] = 0.04175 + m_P[27];
-
-		/* Wheel_left\tf_rotation_to_translation_left\r = 0.101 / 2; */
-		m_P[33] = 0.101 / 2.0;
-
-		/* Wheel_right\tf_rotation_to_translation_right\r = 0.101 / 2; */
-		m_P[35] = 0.101 / 2.0;
+void Plant::CalculateInitial(void)
+{
+                /* Drivetrain_left\Gain\K = (((real) 361 / 5625) * 0.101) / 2; */
+  m_P[2] = (((XXDouble) 361.0 / 5625.0) * 0.101) / 2.0;
+
+                /* Drivetrain_left\J_rotor_left\i = (1.49e-6 + (4.28e-4 + (0.02358) * 0.0505 ^ 2) * ((real) 361 / 5625) ^ 2); */
+  m_P[4] = (1.49e-6 + (4.28e-4 + (0.02358) * (0.0505 * 0.0505)) *
+    XXPow2 (((XXDouble) 361.0 / 5625.0)));
+
+                /* Drivetrain_left\tf_gearbox_reduction_left\r = (real) 361 / 5625; */
+  m_P[7] = (XXDouble) 361.0 / 5625.0;
+
+                /* Drivetrain_right\Gain\K = (((real) 361 / 5625) * 0.101) / 2; */
+  m_P[10] = (((XXDouble) 361.0 / 5625.0) * 0.101) / 2.0;
+
+                /* Drivetrain_right\J_rotor_right\i = (1.49e-6 + (4.28e-4 + (0.02358) * 0.0505 ^ 2) * ((real) 361 / 5625) ^ 2); */
+  m_P[12] = (1.49e-6 + (4.28e-4 + (0.02358) * (0.0505 * 0.0505)) *
+    XXPow2 (((XXDouble) 361.0 / 5625.0)));
+
+                /* Drivetrain_right\tf_gearbox_reduction_right\r = (real) 361 / 5625; */
+  m_P[15] = (XXDouble) 361.0 / 5625.0;
+
+                /* Rigid_body\tf_wheel_left_wrt_CoM\r = [-0.104 - ly_offset; 0.04175 + lx_offset]; */
+  m_M[10].mat[0] = -0.104 - m_P[26];
+  m_M[10].mat[1] = 0.04175 + m_P[27];
+
+                /* Rigid_body\tf_wheel_right_wrt_CoM\r = [0.104 - ly_offset; 0.04175 + lx_offset]; */
+  m_M[12].mat[0] = 0.104 - m_P[26];
+  m_M[12].mat[1] = 0.04175 + m_P[27];
+
+                /* Wheel_left\tf_rotation_to_translation_left\r = 0.101 / 2; */
+  m_P[33] = 0.101 / 2.0;
+
+                /* Wheel_right\tf_rotation_to_translation_right\r = 0.101 / 2; */
+  m_P[35] = 0.101 / 2.0;
@@ -414,13 +413,13 @@
-void Plant::CalculateStatic (void)
-{
-	/* Drivetrain_left\DeadZone1\halfzone = 0.5 * Drivetrain_left\DeadZone1\zone; */
-	m_V[1] = 0.5 * m_P[0];
-
-	/* Drivetrain_right\DeadZone2\halfzone = 0.5 * Drivetrain_right\DeadZone2\zone; */
-	m_V[13] = 0.5 * m_P[8];
-
-	/* Rigid_body\m_RELbot\i = [Rigid_body\m_RELbot\m, 0.0; 0.0, Rigid_body\m_RELbot\m]; */
-	m_M[2].mat[0] = m_P[21];
-	m_M[2].mat[1] = 0.0;
-	m_M[2].mat[2] = 0.0;
-	m_M[2].mat[3] = m_P[21];
+void Plant::CalculateStatic(void)
+{
+        /* Drivetrain_left\DeadZone1\halfzone = 0.5 * Drivetrain_left\DeadZone1\zone; */
+  m_V[1] = 0.5 * m_P[0];
+
+        /* Drivetrain_right\DeadZone2\halfzone = 0.5 * Drivetrain_right\DeadZone2\zone; */
+  m_V[13] = 0.5 * m_P[8];
+
+        /* Rigid_body\m_RELbot\i = [Rigid_body\m_RELbot\m, 0.0; 0.0, Rigid_body\m_RELbot\m]; */
+  m_M[2].mat[0] = m_P[21];
+  m_M[2].mat[1] = 0.0;
+  m_M[2].mat[2] = 0.0;
+  m_M[2].mat[3] = m_P[21];
@@ -434 +433 @@
-void Plant::CalculateInput (void)
+void Plant::CalculateInput(void)
@@ -443,273 +442,273 @@
-void Plant::CalculateDynamic (void)
-{
-	/* Drivetrain_left\Integrate\input = Drivetrain_left\J_rotor_left\state / Drivetrain_left\J_rotor_left\i; */
-	m_R[0] = m_s[1] / m_P[4];
-
-	/* Drivetrain_right\Integrate\input = Drivetrain_right\J_rotor_right\state / Drivetrain_right\J_rotor_right\i; */
-	m_R[2] = m_s[3] / m_P[12];
-
-	/* Rigid_body\c_x_left\p.e = Rigid_body\c_x_left\state / Rigid_body\c_x_left\spring; */
-	m_V[24] = m_s[5] / m_P[16];
-
-	/* Rigid_body\c_x_right\p.e = Rigid_body\c_x_right\state / Rigid_body\c_x_right\spring; */
-	m_V[25] = m_s[6] / m_P[17];
-
-	/* Rigid_body\c_y_left\p.e = Rigid_body\c_y_left\state / Rigid_body\c_y_left\spring; */
-	m_V[26] = m_s[7] / m_P[18];
-
-	/* Rigid_body\c_y_right\p.e = Rigid_body\c_y_right\state / Rigid_body\c_y_right\spring; */
-	m_V[27] = m_s[8] / m_P[19];
-
-	/* Rigid_body\InertialPosition\output = [Rigid_body\InertialPosition\initial1_int; Rigid_body\InertialPosition\initial2_int]; */
-	m_M[0].mat[0] = m_s[9];
-	m_M[0].mat[1] = m_s[10];
-
-	/* Rigid_body\AngleBody\input = Rigid_body\J_RELbot\state / Rigid_body\J_RELbot\i; */
-	m_R[4] = m_s[11] / m_P[20];
-
-	/* Rigid_body\m_RELbot\p.f = inverse (Rigid_body\m_RELbot\i) * Rigid_body\m_RELbot\state; */
-	XXMatrixInverse (&m_M[17], &m_M[2], m_workarray);
-	/* Rigid_body\m_RELbot\p.f = inverse (Rigid_body\m_RELbot\i) * Rigid_body\m_RELbot\state; */
-	XXMatrixMul (&m_M[1], &m_M[17], &m_M[15]);
-
-	/* Drivetrain_left\steer_left = steer_left; */
-	m_V[11] = m_V[90];
-
-	/* Drivetrain_right\steer_right = steer_right; */
-	m_V[23] = m_V[91];
-
-	/* Drivetrain_left\Gain\output = Drivetrain_left\Gain\K * Drivetrain_left\Integrate\output; */
-	m_V[3] = m_P[2] * m_s[0];
-
-	/* Drivetrain_right\Gain\output = Drivetrain_right\Gain\K * Drivetrain_right\Integrate\output; */
-	m_V[15] = m_P[10] * m_s[2];
-
-	/* [Rigid_body\Demux\output1; Rigid_body\Demux\output2] = Rigid_body\InertialPosition\output; */
-	m_V[28] = m_M[0].mat[0];
-	m_V[29] = m_M[0].mat[1];
-
-	/* Drivetrain_left\DeadZone1\output = if Drivetrain_left\steer_left > Drivetrain_left\DeadZone1\halfzone... ; */
-	m_V[0] = ((m_V[11] > m_V[1]) ? 
-		/* Drivetrain_left\steer_left - Drivetrain_left\DeadZone1\halfzone */
-		(m_V[11] - m_V[1])
-	:
-		/* if Drivetrain_left\steer_left < -Drivetrain_left\DeadZone1\halfzone...  */
-		((m_V[11] < -m_V[1]) ? 
-			/* Drivetrain_left\steer_left + Drivetrain_left\DeadZone1\halfzone */
-			(m_V[11] + m_V[1])
-		:
-			/* 0.0 */
-			0.0
-		)
-	);
-
-	/* Drivetrain_left\gy_motor_constant_left\p1.u = Drivetrain_left\gy_motor_constant_left\r * Drivetrain_left\Integrate\input; */
-	m_V[4] = m_P[3] * m_R[0];
-
-	/* Drivetrain_left\R_rotational_friction_left\p.e = Drivetrain_left\R_rotational_friction_left\r * Drivetrain_left\Integrate\input; */
-	m_V[8] = m_P[6] * m_R[0];
-
-	/* Drivetrain_left\tf_gearbox_reduction_left\p2.f = Drivetrain_left\tf_gearbox_reduction_left\r * Drivetrain_left\Integrate\input; */
-	m_V[10] = m_P[7] * m_R[0];
-
-	/* Drivetrain_right\DeadZone2\output = if Drivetrain_right\steer_right > Drivetrain_right\DeadZone2\halfzone... ; */
-	m_V[12] = ((m_V[23] > m_V[13]) ? 
-		/* Drivetrain_right\steer_right - Drivetrain_right\DeadZone2\halfzone */
-		(m_V[23] - m_V[13])
-	:
-		/* if Drivetrain_right\steer_right < -Drivetrain_right\DeadZone2\halfzone...  */
-		((m_V[23] < -m_V[13]) ? 
-			/* Drivetrain_right\steer_right + Drivetrain_right\DeadZone2\halfzone */
-			(m_V[23] + m_V[13])
-		:
-			/* 0.0 */
-			0.0
-		)
-	);
-
-	/* Drivetrain_right\gy_motor_constant_right\p1.u = Drivetrain_right\gy_motor_constant_right\r * Drivetrain_right\Integrate\input; */
-	m_V[16] = m_P[11] * m_R[2];
-
-	/* Drivetrain_right\R_rotational_friction_right\p.e = Drivetrain_right\R_rotational_friction_right\r * Drivetrain_right\Integrate\input; */
-	m_V[20] = m_P[14] * m_R[2];
-
-	/* Drivetrain_right\tf_gearbox_reduction_right\p2.f = Drivetrain_right\tf_gearbox_reduction_right\r * Drivetrain_right\Integrate\input; */
-	m_V[22] = m_P[15] * m_R[2];
-
-	/* new_rate = Rigid_body\m_RELbot\p.f[1,1]; */
-	m_R[9] = m_M[1].mat[0];
-
-	/* new_rate = Rigid_body\m_RELbot\p.f[2,1]; */
-	m_R[10] = m_M[1].mat[1];
-
-	/* Rigid_body\RTF\r = [cos (Rigid_body\AngleBody\output), -sin (Rigid_body\AngleBody\output); sin (Rigid_body\AngleBody\output), cos (Rigid_body\AngleBody\output)]; */
-	m_M[8].mat[0] = cos (m_s[4]);
-	m_M[8].mat[1] = -(sin (m_s[4]));
-	m_M[8].mat[2] = sin (m_s[4]);
-	m_M[8].mat[3] = cos (m_s[4]);
-
-	/* Rigid_body\RTF\p1.f = (1.0 / Rigid_body\RTF\r) * Rigid_body\m_RELbot\p.f; */
-	XXScalarMatrixDiv (&m_M[18], 1.0, &m_M[8], m_workarray);
-	/* Rigid_body\RTF\p1.f = (1.0 / Rigid_body\RTF\r) * Rigid_body\m_RELbot\p.f; */
-	XXMatrixMul (&m_M[7], &m_M[18], &m_M[1]);
-
-	/* Rigid_body\tf_wheel_left_wrt_CoM\p2.f = Rigid_body\tf_wheel_left_wrt_CoM\r * Rigid_body\AngleBody\input; */
-	XXMatrixScalarMul (&m_M[9], &m_M[10], m_R[4]);
-
-	/* Rigid_body\tf_wheel_right_wrt_CoM\p2.f = Rigid_body\tf_wheel_right_wrt_CoM\r * Rigid_body\AngleBody\input; */
-	XXMatrixScalarMul (&m_M[11], &m_M[12], m_R[4]);
-
-	/* Drivetrain_left\DutycycleToVolt\output = Drivetrain_left\DutycycleToVolt\K * Drivetrain_left\DeadZone1\output; */
-	m_V[2] = m_P[1] * m_V[0];
-
-	/* Drivetrain_right\DutycycleToVolt\output = Drivetrain_right\DutycycleToVolt\K * Drivetrain_right\DeadZone2\output; */
-	m_V[14] = m_P[9] * m_V[12];
-
-	/* [Rigid_body\PowerDemuxLeft\output1.f; Rigid_body\PowerDemuxLeft\output2.f] = Rigid_body\tf_wheel_left_wrt_CoM\p2.f; */
-	m_V[43] = m_M[9].mat[0];
-	m_V[46] = m_M[9].mat[1];
-
-	/* [Rigid_body\PowerDemuxRight\output1.f; Rigid_body\PowerDemuxRight\output2.f] = Rigid_body\tf_wheel_right_wrt_CoM\p2.f; */
-	m_V[51] = m_M[11].mat[0];
-	m_V[54] = m_M[11].mat[1];
-
-	/* [Rigid_body\PowerDemuxLeft1\output1.f; Rigid_body\PowerDemuxLeft1\output2.f] = Rigid_body\RTF\p1.f; */
-	m_V[47] = m_M[7].mat[0];
-	m_V[50] = m_M[7].mat[1];
-
-	/* Drivetrain_left\i_actuator_left\p2.u = Drivetrain_left\DutycycleToVolt\output - Drivetrain_left\gy_motor_constant_left\p1.u; */
-	m_V[6] = m_V[2] - m_V[4];
-
-	/* Drivetrain_right\i_actuator_left1\p2.u = Drivetrain_right\DutycycleToVolt\output - Drivetrain_right\gy_motor_constant_right\p1.u; */
-	m_V[18] = m_V[14] - m_V[16];
-
-	/* Rigid_body\c_y_left\p.f = Rigid_body\PowerDemuxLeft1\output2.f + Rigid_body\PowerDemuxLeft\output2.f; */
-	m_R[7] = m_V[50] + m_V[46];
-
-	/* [Rigid_body\PowerDemuxRight1\output1.f; Rigid_body\PowerDemuxRight1\output2.f] = Rigid_body\RTF\p1.f; */
-	m_V[55] = m_M[7].mat[0];
-	m_V[58] = m_M[7].mat[1];
-
-	/* Wheel_left\R_rotational_friction_left\p.e = Wheel_left\R_rotational_friction_left\r * Drivetrain_left\tf_gearbox_reduction_left\p2.f; */
-	m_V[77] = m_P[32] * m_V[10];
-
-	/* Wheel_left\tf_rotation_to_translation_left\p2.f = Wheel_left\tf_rotation_to_translation_left\r * Drivetrain_left\tf_gearbox_reduction_left\p2.f; */
-	m_V[79] = m_P[33] * m_V[10];
-
-	/* Wheel_right\R_rotational_friction_right\p.e = Wheel_right\R_rotational_friction_right\r * Drivetrain_right\tf_gearbox_reduction_right\p2.f; */
-	m_V[81] = m_P[34] * m_V[22];
-
-	/* Wheel_right\tf_rotation_to_translation_right\p2.f = Wheel_right\tf_rotation_to_translation_right\r * Drivetrain_right\tf_gearbox_reduction_right\p2.f; */
-	m_V[83] = m_P[35] * m_V[22];
-
-	/* Drivetrain_left\R_actuator_left\p.f = Drivetrain_left\i_actuator_left\p2.u / Drivetrain_left\R_actuator_left\r; */
-	m_V[7] = m_V[6] / m_P[5];
-
-	/* Drivetrain_right\R_actuator_right\p.f = Drivetrain_right\i_actuator_left1\p2.u / Drivetrain_right\R_actuator_right\r; */
-	m_V[19] = m_V[18] / m_P[13];
-
-	/* Rigid_body\c_y_right\p.f = Rigid_body\PowerDemuxRight1\output2.f + Rigid_body\PowerDemuxRight\output2.f; */
-	m_R[8] = m_V[58] + m_V[54];
-
-	/* Rigid_body\r_y_left\p.e = Rigid_body\r_y_left\r * Rigid_body\c_y_left\p.f; */
-	m_V[67] = m_P[24] * m_R[7];
-
-	/* Drivetrain_left\gy_motor_constant_left\p2.T = Drivetrain_left\gy_motor_constant_left\r * Drivetrain_left\R_actuator_left\p.f; */
-	m_V[5] = m_P[3] * m_V[7];
-
-	/* Drivetrain_right\gy_motor_constant_right\p2.T = Drivetrain_right\gy_motor_constant_right\r * Drivetrain_right\R_actuator_right\p.f; */
-	m_V[17] = m_P[11] * m_V[19];
-
-	/* Rigid_body\OneJunction12\p2.e = Rigid_body\c_y_left\p.e + Rigid_body\r_y_left\p.e; */
-	m_V[39] = m_V[26] + m_V[67];
-
-	/* Rigid_body\r_y_right\p.e = Rigid_body\r_y_right\r * Rigid_body\c_y_right\p.f; */
-	m_V[68] = m_P[25] * m_R[8];
-
-	/* Rigid_body\c_x_left\p.f = (Rigid_body\PowerDemuxLeft1\output1.f + Rigid_body\PowerDemuxLeft\output1.f) - Wheel_left\tf_rotation_to_translation_left\p2.f; */
-	m_R[5] = (m_V[47] + m_V[43]) - m_V[79];
-
-	/* Rigid_body\c_x_right\p.f = (Rigid_body\PowerDemuxRight1\output1.f + Rigid_body\PowerDemuxRight\output1.f) + Wheel_right\tf_rotation_to_translation_right\p2.f; */
-	m_R[6] = (m_V[55] + m_V[51]) + m_V[83];
-
-	/* Rigid_body\OneJunction13\p2.e = Rigid_body\c_y_right\p.e + Rigid_body\r_y_right\p.e; */
-	m_V[40] = m_V[27] + m_V[68];
-
-	/* Rigid_body\r_x_left\p.e = Rigid_body\r_x_left\r * Rigid_body\c_x_left\p.f; */
-	m_V[65] = m_P[22] * m_R[5];
-
-	/* Rigid_body\r_x_right\p.e = Rigid_body\r_x_right\r * Rigid_body\c_x_right\p.f; */
-	m_V[66] = m_P[23] * m_R[6];
-
-	/* Rigid_body\OneJunction8\p1.e = Rigid_body\r_x_left\p.e + Rigid_body\c_x_left\p.e; */
-	m_V[41] = m_V[65] + m_V[24];
-
-	/* Rigid_body\OneJunction9\p1.e = Rigid_body\r_x_right\p.e + Rigid_body\c_x_right\p.e; */
-	m_V[42] = m_V[66] + m_V[25];
-
-	/* Rigid_body\OneJunction\p2.e = -Rigid_body\OneJunction8\p1.e; */
-	m_V[38] = -m_V[41];
-
-	/* Rigid_body\PowerDemuxLeft\input.e = [Rigid_body\OneJunction8\p1.e; Rigid_body\OneJunction12\p2.e]; */
-	m_M[3].mat[0] = m_V[41];
-	m_M[3].mat[1] = m_V[39];
-
-	/* Rigid_body\PowerDemuxLeft1\input.e = [Rigid_body\OneJunction8\p1.e; Rigid_body\OneJunction12\p2.e]; */
-	m_M[4].mat[0] = m_V[41];
-	m_M[4].mat[1] = m_V[39];
-
-	/* Rigid_body\PowerDemuxRight\input.e = [Rigid_body\OneJunction9\p1.e; Rigid_body\OneJunction13\p2.e]; */
-	m_M[5].mat[0] = m_V[42];
-	m_M[5].mat[1] = m_V[40];
-
-	/* Rigid_body\PowerDemuxRight1\input.e = [Rigid_body\OneJunction9\p1.e; Rigid_body\OneJunction13\p2.e]; */
-	m_M[6].mat[0] = m_V[42];
-	m_M[6].mat[1] = m_V[40];
-
-	/* Rigid_body\tf_wheel_left_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_left_wrt_CoM\r) * Rigid_body\PowerDemuxLeft\input.e; */
-	XXMatrixTranspose (&m_M[19], &m_M[10]);
-	/* Rigid_body\tf_wheel_left_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_left_wrt_CoM\r) * Rigid_body\PowerDemuxLeft\input.e; */
-	XXScalarMatrixMatrixMul (&m_V[69], &m_M[19], &m_M[3]);
-
-	/* Rigid_body\tf_wheel_right_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_right_wrt_CoM\r) * Rigid_body\PowerDemuxRight\input.e; */
-	XXMatrixTranspose (&m_M[20], &m_M[12]);
-	/* Rigid_body\tf_wheel_right_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_right_wrt_CoM\r) * Rigid_body\PowerDemuxRight\input.e; */
-	XXScalarMatrixMatrixMul (&m_V[72], &m_M[20], &m_M[5]);
-
-	/* Rigid_body\v_xy_CoM\p3.e = -(Rigid_body\PowerDemuxRight1\input.e + Rigid_body\PowerDemuxLeft1\input.e); */
-	XXMatrixAdd (&m_M[21], &m_M[6], &m_M[4]);
-	/* Rigid_body\v_xy_CoM\p3.e = -(Rigid_body\PowerDemuxRight1\input.e + Rigid_body\PowerDemuxLeft1\input.e); */
-	XXMatrixInv (&m_M[13], &m_M[21]);
-
-	/* Rigid_body\m_RELbot\p.e = (1.0 / transpose (Rigid_body\RTF\r)) * Rigid_body\v_xy_CoM\p3.e; */
-	XXMatrixTranspose (&m_M[23], &m_M[8]);
-	XXScalarMatrixDiv (&m_M[22], 1.0, &m_M[23], m_workarray);
-	/* Rigid_body\m_RELbot\p.e = (1.0 / transpose (Rigid_body\RTF\r)) * Rigid_body\v_xy_CoM\p3.e; */
-	XXMatrixMul (&m_M[14], &m_M[22], &m_M[13]);
-
-	/* Rigid_body\J_RELbot\p.e = -(Rigid_body\tf_wheel_left_wrt_CoM\p1.e + Rigid_body\tf_wheel_right_wrt_CoM\p1.e); */
-	m_R[11] = -(m_V[69] + m_V[72]);
-
-	/* Wheel_left\tf_rotation_to_translation_left\p1.e = Wheel_left\tf_rotation_to_translation_left\r * Rigid_body\OneJunction\p2.e; */
-	m_V[78] = m_P[33] * m_V[38];
-
-	/* Wheel_right\tf_rotation_to_translation_right\p1.e = Wheel_right\tf_rotation_to_translation_right\r * Rigid_body\OneJunction9\p1.e; */
-	m_V[82] = m_P[35] * m_V[42];
-
-	/* Wheel_left\w_wheel_left\p1.T = Wheel_left\tf_rotation_to_translation_left\p1.e + Wheel_left\R_rotational_friction_left\p.e; */
-	m_V[80] = m_V[78] + m_V[77];
-
-	/* Wheel_right\w_wheel_right\p1.T = Wheel_right\tf_rotation_to_translation_right\p1.e + Wheel_right\R_rotational_friction_right\p.e; */
-	m_V[84] = m_V[82] + m_V[81];
-
-	/* Drivetrain_left\tf_gearbox_reduction_left\p1.e = Drivetrain_left\tf_gearbox_reduction_left\r * Wheel_left\w_wheel_left\p1.T; */
-	m_V[9] = m_P[7] * m_V[80];
-
-	/* Drivetrain_right\tf_gearbox_reduction_right\p1.e = Drivetrain_right\tf_gearbox_reduction_right\r * Wheel_right\w_wheel_right\p1.T; */
-	m_V[21] = m_P[15] * m_V[84];
-
-	/* Drivetrain_left\J_rotor_left\p.e = Drivetrain_left\gy_motor_constant_left\p2.T - (Drivetrain_left\tf_gearbox_reduction_left\p1.e + Drivetrain_left\R_rotational_friction_left\p.e); */
-	m_R[1] = m_V[5] - (m_V[9] + m_V[8]);
-
-	/* Drivetrain_right\J_rotor_right\p.e = Drivetrain_right\gy_motor_constant_right\p2.T - (Drivetrain_right\tf_gearbox_reduction_right\p1.e + Drivetrain_right\R_rotational_friction_right\p.e); */
-	m_R[3] = m_V[17] - (m_V[21] + m_V[20]);
+void Plant::CalculateDynamic(void)
+{
+        /* Drivetrain_left\Integrate\input = Drivetrain_left\J_rotor_left\state / Drivetrain_left\J_rotor_left\i; */
+  m_R[0] = m_s[1] / m_P[4];
+
+        /* Drivetrain_right\Integrate\input = Drivetrain_right\J_rotor_right\state / Drivetrain_right\J_rotor_right\i; */
+  m_R[2] = m_s[3] / m_P[12];
+
+        /* Rigid_body\c_x_left\p.e = Rigid_body\c_x_left\state / Rigid_body\c_x_left\spring; */
+  m_V[24] = m_s[5] / m_P[16];
+
+        /* Rigid_body\c_x_right\p.e = Rigid_body\c_x_right\state / Rigid_body\c_x_right\spring; */
+  m_V[25] = m_s[6] / m_P[17];
+
+        /* Rigid_body\c_y_left\p.e = Rigid_body\c_y_left\state / Rigid_body\c_y_left\spring; */
+  m_V[26] = m_s[7] / m_P[18];
+
+        /* Rigid_body\c_y_right\p.e = Rigid_body\c_y_right\state / Rigid_body\c_y_right\spring; */
+  m_V[27] = m_s[8] / m_P[19];
+
+        /* Rigid_body\InertialPosition\output = [Rigid_body\InertialPosition\initial1_int; Rigid_body\InertialPosition\initial2_int]; */
+  m_M[0].mat[0] = m_s[9];
+  m_M[0].mat[1] = m_s[10];
+
+        /* Rigid_body\AngleBody\input = Rigid_body\J_RELbot\state / Rigid_body\J_RELbot\i; */
+  m_R[4] = m_s[11] / m_P[20];
+
+        /* Rigid_body\m_RELbot\p.f = inverse (Rigid_body\m_RELbot\i) * Rigid_body\m_RELbot\state; */
+  XXMatrixInverse (&m_M[17], &m_M[2], m_workarray);
+        /* Rigid_body\m_RELbot\p.f = inverse (Rigid_body\m_RELbot\i) * Rigid_body\m_RELbot\state; */
+  XXMatrixMul (&m_M[1], &m_M[17], &m_M[15]);
+
+        /* Drivetrain_left\steer_left = steer_left; */
+  m_V[11] = m_V[90];
+
+        /* Drivetrain_right\steer_right = steer_right; */
+  m_V[23] = m_V[91];
+
+        /* Drivetrain_left\Gain\output = Drivetrain_left\Gain\K * Drivetrain_left\Integrate\output; */
+  m_V[3] = m_P[2] * m_s[0];
+
+        /* Drivetrain_right\Gain\output = Drivetrain_right\Gain\K * Drivetrain_right\Integrate\output; */
+  m_V[15] = m_P[10] * m_s[2];
+
+        /* [Rigid_body\Demux\output1; Rigid_body\Demux\output2] = Rigid_body\InertialPosition\output; */
+  m_V[28] = m_M[0].mat[0];
+  m_V[29] = m_M[0].mat[1];
+
+        /* Drivetrain_left\DeadZone1\output = if Drivetrain_left\steer_left > Drivetrain_left\DeadZone1\halfzone... ; */
+  m_V[0] = ((m_V[11] > m_V[1]) ?
+                /* Drivetrain_left\steer_left - Drivetrain_left\DeadZone1\halfzone */
+    (m_V[11] - m_V[1])
+    :
+                /* if Drivetrain_left\steer_left < -Drivetrain_left\DeadZone1\halfzone...  */
+    ((m_V[11] < -m_V[1]) ?
+                        /* Drivetrain_left\steer_left + Drivetrain_left\DeadZone1\halfzone */
+    (m_V[11] + m_V[1])
+    :
+                        /* 0.0 */
+    0.0
+    )
+  );
+
+        /* Drivetrain_left\gy_motor_constant_left\p1.u = Drivetrain_left\gy_motor_constant_left\r * Drivetrain_left\Integrate\input; */
+  m_V[4] = m_P[3] * m_R[0];
+
+        /* Drivetrain_left\R_rotational_friction_left\p.e = Drivetrain_left\R_rotational_friction_left\r * Drivetrain_left\Integrate\input; */
+  m_V[8] = m_P[6] * m_R[0];
+
+        /* Drivetrain_left\tf_gearbox_reduction_left\p2.f = Drivetrain_left\tf_gearbox_reduction_left\r * Drivetrain_left\Integrate\input; */
+  m_V[10] = m_P[7] * m_R[0];
+
+        /* Drivetrain_right\DeadZone2\output = if Drivetrain_right\steer_right > Drivetrain_right\DeadZone2\halfzone... ; */
+  m_V[12] = ((m_V[23] > m_V[13]) ?
+                /* Drivetrain_right\steer_right - Drivetrain_right\DeadZone2\halfzone */
+    (m_V[23] - m_V[13])
+    :
+                /* if Drivetrain_right\steer_right < -Drivetrain_right\DeadZone2\halfzone...  */
+    ((m_V[23] < -m_V[13]) ?
+                        /* Drivetrain_right\steer_right + Drivetrain_right\DeadZone2\halfzone */
+    (m_V[23] + m_V[13])
+    :
+                        /* 0.0 */
+    0.0
+    )
+  );
+
+        /* Drivetrain_right\gy_motor_constant_right\p1.u = Drivetrain_right\gy_motor_constant_right\r * Drivetrain_right\Integrate\input; */
+  m_V[16] = m_P[11] * m_R[2];
+
+        /* Drivetrain_right\R_rotational_friction_right\p.e = Drivetrain_right\R_rotational_friction_right\r * Drivetrain_right\Integrate\input; */
+  m_V[20] = m_P[14] * m_R[2];
+
+        /* Drivetrain_right\tf_gearbox_reduction_right\p2.f = Drivetrain_right\tf_gearbox_reduction_right\r * Drivetrain_right\Integrate\input; */
+  m_V[22] = m_P[15] * m_R[2];
+
+        /* new_rate = Rigid_body\m_RELbot\p.f[1,1]; */
+  m_R[9] = m_M[1].mat[0];
+
+        /* new_rate = Rigid_body\m_RELbot\p.f[2,1]; */
+  m_R[10] = m_M[1].mat[1];
+
+        /* Rigid_body\RTF\r = [cos (Rigid_body\AngleBody\output), -sin (Rigid_body\AngleBody\output); sin (Rigid_body\AngleBody\output), cos (Rigid_body\AngleBody\output)]; */
+  m_M[8].mat[0] = cos (m_s[4]);
+  m_M[8].mat[1] = -(sin (m_s[4]));
+  m_M[8].mat[2] = sin (m_s[4]);
+  m_M[8].mat[3] = cos (m_s[4]);
+
+        /* Rigid_body\RTF\p1.f = (1.0 / Rigid_body\RTF\r) * Rigid_body\m_RELbot\p.f; */
+  XXScalarMatrixDiv (&m_M[18], 1.0, &m_M[8], m_workarray);
+        /* Rigid_body\RTF\p1.f = (1.0 / Rigid_body\RTF\r) * Rigid_body\m_RELbot\p.f; */
+  XXMatrixMul (&m_M[7], &m_M[18], &m_M[1]);
+
+        /* Rigid_body\tf_wheel_left_wrt_CoM\p2.f = Rigid_body\tf_wheel_left_wrt_CoM\r * Rigid_body\AngleBody\input; */
+  XXMatrixScalarMul (&m_M[9], &m_M[10], m_R[4]);
+
+        /* Rigid_body\tf_wheel_right_wrt_CoM\p2.f = Rigid_body\tf_wheel_right_wrt_CoM\r * Rigid_body\AngleBody\input; */
+  XXMatrixScalarMul (&m_M[11], &m_M[12], m_R[4]);
+
+        /* Drivetrain_left\DutycycleToVolt\output = Drivetrain_left\DutycycleToVolt\K * Drivetrain_left\DeadZone1\output; */
+  m_V[2] = m_P[1] * m_V[0];
+
+        /* Drivetrain_right\DutycycleToVolt\output = Drivetrain_right\DutycycleToVolt\K * Drivetrain_right\DeadZone2\output; */
+  m_V[14] = m_P[9] * m_V[12];
+
+        /* [Rigid_body\PowerDemuxLeft\output1.f; Rigid_body\PowerDemuxLeft\output2.f] = Rigid_body\tf_wheel_left_wrt_CoM\p2.f; */
+  m_V[43] = m_M[9].mat[0];
+  m_V[46] = m_M[9].mat[1];
+
+        /* [Rigid_body\PowerDemuxRight\output1.f; Rigid_body\PowerDemuxRight\output2.f] = Rigid_body\tf_wheel_right_wrt_CoM\p2.f; */
+  m_V[51] = m_M[11].mat[0];
+  m_V[54] = m_M[11].mat[1];
+
+        /* [Rigid_body\PowerDemuxLeft1\output1.f; Rigid_body\PowerDemuxLeft1\output2.f] = Rigid_body\RTF\p1.f; */
+  m_V[47] = m_M[7].mat[0];
+  m_V[50] = m_M[7].mat[1];
+
+        /* Drivetrain_left\i_actuator_left\p2.u = Drivetrain_left\DutycycleToVolt\output - Drivetrain_left\gy_motor_constant_left\p1.u; */
+  m_V[6] = m_V[2] - m_V[4];
+
+        /* Drivetrain_right\i_actuator_left1\p2.u = Drivetrain_right\DutycycleToVolt\output - Drivetrain_right\gy_motor_constant_right\p1.u; */
+  m_V[18] = m_V[14] - m_V[16];
+
+        /* Rigid_body\c_y_left\p.f = Rigid_body\PowerDemuxLeft1\output2.f + Rigid_body\PowerDemuxLeft\output2.f; */
+  m_R[7] = m_V[50] + m_V[46];
+
+        /* [Rigid_body\PowerDemuxRight1\output1.f; Rigid_body\PowerDemuxRight1\output2.f] = Rigid_body\RTF\p1.f; */
+  m_V[55] = m_M[7].mat[0];
+  m_V[58] = m_M[7].mat[1];
+
+        /* Wheel_left\R_rotational_friction_left\p.e = Wheel_left\R_rotational_friction_left\r * Drivetrain_left\tf_gearbox_reduction_left\p2.f; */
+  m_V[77] = m_P[32] * m_V[10];
+
+        /* Wheel_left\tf_rotation_to_translation_left\p2.f = Wheel_left\tf_rotation_to_translation_left\r * Drivetrain_left\tf_gearbox_reduction_left\p2.f; */
+  m_V[79] = m_P[33] * m_V[10];
+
+        /* Wheel_right\R_rotational_friction_right\p.e = Wheel_right\R_rotational_friction_right\r * Drivetrain_right\tf_gearbox_reduction_right\p2.f; */
+  m_V[81] = m_P[34] * m_V[22];
+
+        /* Wheel_right\tf_rotation_to_translation_right\p2.f = Wheel_right\tf_rotation_to_translation_right\r * Drivetrain_right\tf_gearbox_reduction_right\p2.f; */
+  m_V[83] = m_P[35] * m_V[22];
+
+        /* Drivetrain_left\R_actuator_left\p.f = Drivetrain_left\i_actuator_left\p2.u / Drivetrain_left\R_actuator_left\r; */
+  m_V[7] = m_V[6] / m_P[5];
+
+        /* Drivetrain_right\R_actuator_right\p.f = Drivetrain_right\i_actuator_left1\p2.u / Drivetrain_right\R_actuator_right\r; */
+  m_V[19] = m_V[18] / m_P[13];
+
+        /* Rigid_body\c_y_right\p.f = Rigid_body\PowerDemuxRight1\output2.f + Rigid_body\PowerDemuxRight\output2.f; */
+  m_R[8] = m_V[58] + m_V[54];
+
+        /* Rigid_body\r_y_left\p.e = Rigid_body\r_y_left\r * Rigid_body\c_y_left\p.f; */
+  m_V[67] = m_P[24] * m_R[7];
+
+        /* Drivetrain_left\gy_motor_constant_left\p2.T = Drivetrain_left\gy_motor_constant_left\r * Drivetrain_left\R_actuator_left\p.f; */
+  m_V[5] = m_P[3] * m_V[7];
+
+        /* Drivetrain_right\gy_motor_constant_right\p2.T = Drivetrain_right\gy_motor_constant_right\r * Drivetrain_right\R_actuator_right\p.f; */
+  m_V[17] = m_P[11] * m_V[19];
+
+        /* Rigid_body\OneJunction12\p2.e = Rigid_body\c_y_left\p.e + Rigid_body\r_y_left\p.e; */
+  m_V[39] = m_V[26] + m_V[67];
+
+        /* Rigid_body\r_y_right\p.e = Rigid_body\r_y_right\r * Rigid_body\c_y_right\p.f; */
+  m_V[68] = m_P[25] * m_R[8];
+
+        /* Rigid_body\c_x_left\p.f = (Rigid_body\PowerDemuxLeft1\output1.f + Rigid_body\PowerDemuxLeft\output1.f) - Wheel_left\tf_rotation_to_translation_left\p2.f; */
+  m_R[5] = (m_V[47] + m_V[43]) - m_V[79];
+
+        /* Rigid_body\c_x_right\p.f = (Rigid_body\PowerDemuxRight1\output1.f + Rigid_body\PowerDemuxRight\output1.f) + Wheel_right\tf_rotation_to_translation_right\p2.f; */
+  m_R[6] = (m_V[55] + m_V[51]) + m_V[83];
+
+        /* Rigid_body\OneJunction13\p2.e = Rigid_body\c_y_right\p.e + Rigid_body\r_y_right\p.e; */
+  m_V[40] = m_V[27] + m_V[68];
+
+        /* Rigid_body\r_x_left\p.e = Rigid_body\r_x_left\r * Rigid_body\c_x_left\p.f; */
+  m_V[65] = m_P[22] * m_R[5];
+
+        /* Rigid_body\r_x_right\p.e = Rigid_body\r_x_right\r * Rigid_body\c_x_right\p.f; */
+  m_V[66] = m_P[23] * m_R[6];
+
+        /* Rigid_body\OneJunction8\p1.e = Rigid_body\r_x_left\p.e + Rigid_body\c_x_left\p.e; */
+  m_V[41] = m_V[65] + m_V[24];
+
+        /* Rigid_body\OneJunction9\p1.e = Rigid_body\r_x_right\p.e + Rigid_body\c_x_right\p.e; */
+  m_V[42] = m_V[66] + m_V[25];
+
+        /* Rigid_body\OneJunction\p2.e = -Rigid_body\OneJunction8\p1.e; */
+  m_V[38] = -m_V[41];
+
+        /* Rigid_body\PowerDemuxLeft\input.e = [Rigid_body\OneJunction8\p1.e; Rigid_body\OneJunction12\p2.e]; */
+  m_M[3].mat[0] = m_V[41];
+  m_M[3].mat[1] = m_V[39];
+
+        /* Rigid_body\PowerDemuxLeft1\input.e = [Rigid_body\OneJunction8\p1.e; Rigid_body\OneJunction12\p2.e]; */
+  m_M[4].mat[0] = m_V[41];
+  m_M[4].mat[1] = m_V[39];
+
+        /* Rigid_body\PowerDemuxRight\input.e = [Rigid_body\OneJunction9\p1.e; Rigid_body\OneJunction13\p2.e]; */
+  m_M[5].mat[0] = m_V[42];
+  m_M[5].mat[1] = m_V[40];
+
+        /* Rigid_body\PowerDemuxRight1\input.e = [Rigid_body\OneJunction9\p1.e; Rigid_body\OneJunction13\p2.e]; */
+  m_M[6].mat[0] = m_V[42];
+  m_M[6].mat[1] = m_V[40];
+
+        /* Rigid_body\tf_wheel_left_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_left_wrt_CoM\r) * Rigid_body\PowerDemuxLeft\input.e; */
+  XXMatrixTranspose (&m_M[19], &m_M[10]);
+        /* Rigid_body\tf_wheel_left_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_left_wrt_CoM\r) * Rigid_body\PowerDemuxLeft\input.e; */
+  XXScalarMatrixMatrixMul (&m_V[69], &m_M[19], &m_M[3]);
+
+        /* Rigid_body\tf_wheel_right_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_right_wrt_CoM\r) * Rigid_body\PowerDemuxRight\input.e; */
+  XXMatrixTranspose (&m_M[20], &m_M[12]);
+        /* Rigid_body\tf_wheel_right_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_right_wrt_CoM\r) * Rigid_body\PowerDemuxRight\input.e; */
+  XXScalarMatrixMatrixMul (&m_V[72], &m_M[20], &m_M[5]);
+
+        /* Rigid_body\v_xy_CoM\p3.e = -(Rigid_body\PowerDemuxRight1\input.e + Rigid_body\PowerDemuxLeft1\input.e); */
+  XXMatrixAdd (&m_M[21], &m_M[6], &m_M[4]);
+        /* Rigid_body\v_xy_CoM\p3.e = -(Rigid_body\PowerDemuxRight1\input.e + Rigid_body\PowerDemuxLeft1\input.e); */
+  XXMatrixInv (&m_M[13], &m_M[21]);
+
+        /* Rigid_body\m_RELbot\p.e = (1.0 / transpose (Rigid_body\RTF\r)) * Rigid_body\v_xy_CoM\p3.e; */
+  XXMatrixTranspose (&m_M[23], &m_M[8]);
+  XXScalarMatrixDiv (&m_M[22], 1.0, &m_M[23], m_workarray);
+        /* Rigid_body\m_RELbot\p.e = (1.0 / transpose (Rigid_body\RTF\r)) * Rigid_body\v_xy_CoM\p3.e; */
+  XXMatrixMul (&m_M[14], &m_M[22], &m_M[13]);
+
+        /* Rigid_body\J_RELbot\p.e = -(Rigid_body\tf_wheel_left_wrt_CoM\p1.e + Rigid_body\tf_wheel_right_wrt_CoM\p1.e); */
+  m_R[11] = -(m_V[69] + m_V[72]);
+
+        /* Wheel_left\tf_rotation_to_translation_left\p1.e = Wheel_left\tf_rotation_to_translation_left\r * Rigid_body\OneJunction\p2.e; */
+  m_V[78] = m_P[33] * m_V[38];
+
+        /* Wheel_right\tf_rotation_to_translation_right\p1.e = Wheel_right\tf_rotation_to_translation_right\r * Rigid_body\OneJunction9\p1.e; */
+  m_V[82] = m_P[35] * m_V[42];
+
+        /* Wheel_left\w_wheel_left\p1.T = Wheel_left\tf_rotation_to_translation_left\p1.e + Wheel_left\R_rotational_friction_left\p.e; */
+  m_V[80] = m_V[78] + m_V[77];
+
+        /* Wheel_right\w_wheel_right\p1.T = Wheel_right\tf_rotation_to_translation_right\p1.e + Wheel_right\R_rotational_friction_right\p.e; */
+  m_V[84] = m_V[82] + m_V[81];
+
+        /* Drivetrain_left\tf_gearbox_reduction_left\p1.e = Drivetrain_left\tf_gearbox_reduction_left\r * Wheel_left\w_wheel_left\p1.T; */
+  m_V[9] = m_P[7] * m_V[80];
+
+        /* Drivetrain_right\tf_gearbox_reduction_right\p1.e = Drivetrain_right\tf_gearbox_reduction_right\r * Wheel_right\w_wheel_right\p1.T; */
+  m_V[21] = m_P[15] * m_V[84];
+
+        /* Drivetrain_left\J_rotor_left\p.e = Drivetrain_left\gy_motor_constant_left\p2.T - (Drivetrain_left\tf_gearbox_reduction_left\p1.e + Drivetrain_left\R_rotational_friction_left\p.e); */
+  m_R[1] = m_V[5] - (m_V[9] + m_V[8]);
+
+        /* Drivetrain_right\J_rotor_right\p.e = Drivetrain_right\gy_motor_constant_right\p2.T - (Drivetrain_right\tf_gearbox_reduction_right\p1.e + Drivetrain_right\R_rotational_friction_right\p.e); */
+  m_R[3] = m_V[17] - (m_V[21] + m_V[20]);
@@ -725,16 +724,16 @@
-void Plant::CalculateOutput (void)
-{
-	/* c_position_x = Rigid_body\Demux\output1; */
-	m_V[85] = m_V[28];
-
-	/* d_position_y = Rigid_body\Demux\output2; */
-	m_V[86] = m_V[29];
-
-	/* a_pos_feedback_left = Drivetrain_left\Gain\output; */
-	m_V[87] = m_V[3];
-
-	/* b_pos_feedback_right = Drivetrain_right\Gain\output; */
-	m_V[88] = m_V[15];
-
-	/* e_theta_z = Rigid_body\AngleBody\output; */
-	m_V[89] = m_s[4];
+void Plant::CalculateOutput(void)
+{
+        /* c_position_x = Rigid_body\Demux\output1; */
+  m_V[85] = m_V[28];
+
+        /* d_position_y = Rigid_body\Demux\output2; */
+  m_V[86] = m_V[29];
+
+        /* a_pos_feedback_left = Drivetrain_left\Gain\output; */
+  m_V[87] = m_V[3];
+
+        /* b_pos_feedback_right = Drivetrain_right\Gain\output; */
+  m_V[88] = m_V[15];
+
+        /* e_theta_z = Rigid_body\AngleBody\output; */
+  m_V[89] = m_s[4];
@@ -748,5 +747,4 @@
-void Plant::CalculateFinal (void)
-{
-
-}
-
+void Plant::CalculateFinal(void)
+{
+
+}
@@ -757,9 +755,7 @@
-	if ((newtime <= 0.0) || ( newtime > m_time))
-	{
-		m_finish_time = newtime;
-		return true;
-	}
-
-	return false;
-}
-
+  if ((newtime <= 0.0) || ( newtime > m_time)) {
+    m_finish_time = newtime;
+    return true;
+  }
+
+  return false;
+}
]]></failure>
  </testcase>
  <testcase
    name="src/relbot_simulator.cpp"
    classname="relbot_simulator.uncrustify"
  >
      <failure message="Diff with 86 lines"><![CDATA[--- src/relbot_simulator.cpp
+++ src/relbot_simulator.cpp.uncrustify
@@ -6 +6,2 @@
-RELbotSimulator::RELbotSimulator(double time_step) : Node("RELbot_simulator")
+RELbotSimulator::RELbotSimulator(double time_step)
+: Node("RELbot_simulator")
@@ -13,2 +14 @@
-  if (time_step == 0.0)
-  {
+  if (time_step == 0.0) {
@@ -19,3 +19,5 @@
-  dynamics_timer_ = this->create_wall_timer(std::chrono::duration<double>(time_step), std::bind(&RELbotSimulator::dynamics_timer_callback, this));
-
-  image_stream_timer_ = this->create_wall_timer(std::chrono::duration<double>(1.0 / image_stream_FPS), std::bind(&RELbotSimulator::image_stream_timer_callback, this));
+  dynamics_timer_ = this->create_wall_timer(std::chrono::duration<double>(time_step),
+    std::bind(&RELbotSimulator::dynamics_timer_callback, this));
+
+  image_stream_timer_ = this->create_wall_timer(std::chrono::duration<double>(1.0 /
+    image_stream_FPS), std::bind(&RELbotSimulator::image_stream_timer_callback, this));
@@ -49,3 +51,6 @@
-  moving_camera_output_topic_ = this->create_publisher<sensor_msgs::msg::Image>("output/moving_camera", 1);
-  camera_position_topic_ = this->create_publisher<geometry_msgs::msg::PointStamped>("output/camera_position", 1);
-  robot_pose_topic = this->create_publisher<geometry_msgs::msg::PoseStamped>("output/robot_pose", 1);
+  moving_camera_output_topic_ =
+    this->create_publisher<sensor_msgs::msg::Image>("output/moving_camera", 1);
+  camera_position_topic_ =
+    this->create_publisher<geometry_msgs::msg::PointStamped>("output/camera_position", 1);
+  robot_pose_topic = this->create_publisher<geometry_msgs::msg::PoseStamped>("output/robot_pose",
+    1);
@@ -61,4 +66,4 @@
-      RELbotSimulator::WEBCAM_IMAGE, 10, std::bind(&RELbotSimulator::webcam_topic_callback, this, _1));
-
-  if (RELbotSimulator::useTwistCmd_)
-  {
+      RELbotSimulator::WEBCAM_IMAGE, 10,
+    std::bind(&RELbotSimulator::webcam_topic_callback, this, _1));
+
+  if (RELbotSimulator::useTwistCmd_) {
@@ -71,3 +76 @@
-  }
-  else
-  {
+  } else {
@@ -78 +81 @@
-        RELbotSimulator::RIGHT_MOTOR_NAMESPACE + RELbotSimulator::SETPOINT_VEL_TOPIC;
+      RELbotSimulator::RIGHT_MOTOR_NAMESPACE + RELbotSimulator::SETPOINT_VEL_TOPIC;
@@ -85 +88 @@
-        RELbotSimulator::LEFT_MOTOR_NAMESPACE + RELbotSimulator::SETPOINT_VEL_TOPIC;
+      RELbotSimulator::LEFT_MOTOR_NAMESPACE + RELbotSimulator::SETPOINT_VEL_TOPIC;
@@ -111,4 +114,6 @@
-    /* Hi students, code author here. Twists and reference frames are confusing and need rigid definitions. Even ChatGPT struggled with comprehending this . 
-    Also, just using separate wheel velocities is totally okay and the originally intended way to control this sim  */
-  left_wheel_vel = -((linearVelSetpoint - ((angularVelSetpoint * wheelBaseWidth_) / 2)) / wheelRadius_);
-  right_wheel_vel = ((linearVelSetpoint + ((angularVelSetpoint * wheelBaseWidth_) / 2)) / wheelRadius_);
+  /* Hi students, code author here. Twists and reference frames are confusing and need rigid definitions. Even ChatGPT struggled with comprehending this .
+  Also, just using separate wheel velocities is totally okay and the originally intended way to control this sim  */
+  left_wheel_vel = -((linearVelSetpoint - ((angularVelSetpoint * wheelBaseWidth_) / 2)) /
+    wheelRadius_);
+  right_wheel_vel = ((linearVelSetpoint + ((angularVelSetpoint * wheelBaseWidth_) / 2)) /
+    wheelRadius_);
@@ -122 +127,2 @@
-void RELbotSimulator::rightMotorSetpointVelCallback(const example_interfaces::msg::Float64::SharedPtr setpointVel)
+void RELbotSimulator::rightMotorSetpointVelCallback(
+  const example_interfaces::msg::Float64::SharedPtr setpointVel)
@@ -128 +134,2 @@
-void RELbotSimulator::leftMotorSetpointVelCallback(const example_interfaces::msg::Float64::SharedPtr setpointVel)
+void RELbotSimulator::leftMotorSetpointVelCallback(
+  const example_interfaces::msg::Float64::SharedPtr setpointVel)
@@ -151 +158,3 @@
-  RCLCPP_INFO_THROTTLE(this->get_logger(), clock, 500, "Sim state!   [time, x,y, z] = [%f, %f, %f, %f]", duration.seconds(), output_vector[2], output_vector[3], output_vector[4]);
+  RCLCPP_INFO_THROTTLE(this->get_logger(), clock, 500,
+    "Sim state!   [time, x,y, z] = [%f, %f, %f, %f]", duration.seconds(), output_vector[2],
+    output_vector[3], output_vector[4]);
@@ -177,2 +186 @@
-  if (input_image == nullptr)
-  {
+  if (input_image == nullptr) {
@@ -198 +206,2 @@
-  output_image_ = RELbotSimulator::CreateCVSubimage(input_image, center_pixel_x, center_pixel_y, output_image_dim);
+  output_image_ = RELbotSimulator::CreateCVSubimage(input_image, center_pixel_x, center_pixel_y,
+    output_image_dim);
@@ -220 +229,3 @@
-cv::Mat RELbotSimulator::CreateCVSubimage(const sensor_msgs::msg::Image::SharedPtr msg_cam_img, const int center_pixel_x, const int center_pixel_y, int output_image_dim)
+cv::Mat RELbotSimulator::CreateCVSubimage(
+  const sensor_msgs::msg::Image::SharedPtr msg_cam_img,
+  const int center_pixel_x, const int center_pixel_y, int output_image_dim)
]]></failure>
  </testcase>
  <system-out>Checked files:
* common/EulerAngles.cpp
* common/EulerAngles.h
* common/MotionProfiles.cpp
* common/MotionProfiles.h
* common/xxfuncs.cpp
* common/xxfuncs.h
* common/xxinteg.cpp
* common/xxinteg.h
* common/xxinverse.cpp
* common/xxinverse.h
* common/xxmatrix.cpp
* common/xxmatrix.h
* common/xxmodel.h
* common/xxtypes.h
* include/Plant.h
* include/relbot_simulator.hpp
* src/Plant.cpp
* src/relbot_simulator.cpp</system-out>
</testsuite>
